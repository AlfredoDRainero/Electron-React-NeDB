{"version":3,"file":"index.js","mappings":";;;;;;;;;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,aAAa;AACb;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW,KAA6B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;ACp3BD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8CA8C8C,qEAA0C;;YAE5E,OAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChDN;;AAEb,uGAAsC;AACtC,2HAAsD;;;;;;;;;;;ACHzC;;AAEb;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,0DAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,IAAI;AAC9D,gEAAgE,IAAI;AACpE;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;;;;;;;;;;AC5Ca;;AAEb,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,kBAAM;AAClB;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,0DAAS;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH;AAClH;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;;;;;;;;;;AClEa;;AAEb;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,0DAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnCa;;AAEb;AACA;AACA;AACA;;;;;;;;;;;ACLa;;AAEb;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,0DAAS;AACrB;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;;;;;;;;;;;ACba;;AAEb;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,0DAAS;AACrB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChBa;;AAEb;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,0DAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,WAAW,IAAI,MAAM;AACtE;AACA;AACA,iDAAiD,WAAW,IAAI,MAAM;AACtE;;AAEA;AACA;AACA;AACA,iDAAiD,WAAW,IAAI,MAAM;AACtE;;AAEA;AACA;AACA;AACA,iDAAiD,WAAW,IAAI,MAAM;AACtE;AACA;AACA,iDAAiD,WAAW,IAAI,MAAM;AACtE;AACA;AACA,kDAAkD,WAAW,IAAI,MAAM;AACvE;;AAEA;AACA;AACA;AACA;AACA;AACA,mDAAmD,WAAW,IAAI,MAAM;AACxE;AACA,IAAI;AACJ;AACA;AACA;AACA,iDAAiD,WAAW,IAAI,MAAM;AACtE;AACA;AACA,kDAAkD,WAAW,IAAI,MAAM;AACvE;AACA;AACA;AACA,mDAAmD,WAAW,IAAI,MAAM,kCAAkC,UAAU;AACpH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mDAAmD,WAAW,IAAI,MAAM;AACxE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mDAAmD,WAAW,IAAI,MAAM;AACxE;AACA;;AAEA;AACA,yEAAyE,KAAK;AAC9E,4BAA4B,6BAA6B,EAAE;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR,qDAAqD,WAAW;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,WAAW,6CAA6C,IAAI;AAC/G;AACA;AACA;AACA;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF,wEAAwE;AACxE,8BAA8B,wBAAwB;AACtD;;;;;;;;;;;ACnLa;;AAEb;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,0DAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtGa;;AAEb;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,0DAAS;AACrB,eAAe;AACf;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;AC3Da;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxBa;;AAEb,wBAAwB;AACxB;AACA;AACA,yCAAyC,IAAI;AAC7C;AACA;AACA;AACA,aAAa;AACb,eAAe;;;;;;;;;;ACVf,sHAAsD;AACtD,qHAAiD;;;;;;;;;;ACDjD;AACA;AACA;AACA,uBAAuB,mBAAO,CAAC,2DAAO;AACtC,gBAAgB,mBAAO,CAAC,2EAAe;AACvC,SAAS,mBAAO,CAAC,kBAAM;AACvB,MAAM,mBAAO,CAAC,2DAAY;;AAE1B;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,qBAAqB;AACrB;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;;;;;;;;;ACneA;AACA;AACA;AACA,kBAAkB,mBAAO,CAAC,2EAAe;;AAEzC;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACzjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;;;;;;;;;;AC9CxC,WAAW,mBAAO,CAAC,kBAAM;AACzB,SAAS,mBAAO,CAAC,cAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD,SAAS;AACT;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACxFA,gBAAgB,mBAAO,CAAC,6DAAiB;AACzC;;;;;;;;;;ACDA;AACA;AACA;AACA,YAAY,mBAAO,CAAC,iDAAS;AAC7B,MAAM,mBAAO,CAAC,2DAAY;;AAE1B;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAW,2BAA2B,cAAc;AAC/D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ,0CAA0C,mCAAmC,mBAAmB;AACnH,kCAAkC,mBAAmB;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,8BAA8B;AAC9B,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;;;;;;;;;ACtNA,aAAa,mBAAO,CAAC,sBAAQ;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;;;;;;;;;;ACflB,kBAAkB,mBAAO,CAAC,6DAAe;AACzC,UAAU,mBAAO,CAAC,iDAAS;AAC3B,UAAU,mBAAO,CAAC,gDAAO;AACzB,aAAa,mBAAO,CAAC,uDAAY;AACjC,UAAU,mBAAO,CAAC,qDAAW;AAC7B,SAAS,mBAAO,CAAC,kBAAM;AACvB,MAAM,mBAAO,CAAC,2DAAY;AAC1B,gBAAgB,mBAAO,CAAC,6DAAe;AACvC,WAAW,mBAAO,CAAC,mDAAU;;AAE7B;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACA,WAAW,SAAS;AACpB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,yBAAyB,0DAA8B;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,8DAA8D,iBAAiB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO,IAAI;AACX;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yBAAyB;AACvC;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;;;;;;;;AC5uBA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,gDAAO;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wBAAwB;AACtC;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;AC7EA,uBAAuB,qGAAqC;AAC5D,UAAU,mBAAO,CAAC,iDAAS;AAC3B,MAAM,mBAAO,CAAC,2DAAY;AAC1B,SAAS,mBAAO,CAAC,kBAAM;;AAEvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA,WAAW,gCAAgC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,+BAA+B;AAC1C;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,iBAAiB;AACjB;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;;;;;;;;;AC9RA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,kBAAM;AACzB,MAAM,mBAAO,CAAC,2DAAY;AAC1B,wBAAwB;AACxB,gCAAgC;AAChC,0BAA0B;AAC1B,uBAAuB;AACvB;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,yEAAyE,iBAAiB,KAAK;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kCAAkC;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,0CAA0C;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,+BAA+B;AAC/C;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,aAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,aAAa;AACtD,gBAAgB,qBAAqB;AACrC;AACA;AACA,OAAO;AACP;AACA,QAAQ;AACR;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,+CAA+C;AAC/C;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB,0BAA0B;AAC1B,uBAAuB;AACvB,0BAA0B;AAC1B,8BAA8B;AAC9B,qBAAqB;AACrB,0BAA0B;AAC1B,oBAAoB;AACpB,6BAA6B;AAC7B,4BAA4B;;;;;;;;;;ACz4B5B;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,mBAAO,CAAC,qDAAW;AACjC,SAAS,mBAAO,CAAC,kBAAM;AACvB,UAAU,mBAAO,CAAC,iDAAS;AAC3B,UAAU,mBAAO,CAAC,gDAAO;AACzB,gBAAgB,mBAAO,CAAC,6DAAe;AACvC,UAAU,mBAAO,CAAC,qDAAW;;AAE7B;AACA;AACA,WAAW,WAAW;AACtB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA,qCAAqC;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,YAAY;AACZ,oCAAoC;AACpC;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;;;;;;;;;AC1TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,mBAAO,CAAC,cAAI;AACrB,WAAW,mBAAO,CAAC,8CAAQ;AAC3B,UAAU,mBAAO,CAAC,gDAAO;AACzB,SAAS,mBAAO,CAAC,kBAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;;;;;;;;;;AC/IA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,IAA8B;AACpC,QAAQ,KAA6B;AACrC;AACA;AACA,IAAI,SAAS;AACb,IAAI,KAAK,EAEN;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,sCAAsC,OAAO;AAC7C;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,qDAAqD;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,IAAyB;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB,gBAAgB;AAChB,kBAAkB;AAClB,kBAAkB;AAClB,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,KAAK;AACL,iBAAiB;;AAEjB;AACA,kDAAkD,EAAE,iBAAiB;AACrE,4EAA4E,8BAA8B,2BAA2B;AACrI;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sEAAsE,iBAAiB;AACvF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;;;;;;;;;AC7sCD,MAAM;EAAEA;AAAI,CAAC,GAAGC,mBAAO,CAAC,0BAAU,CAAC;AACnC,MAAMC,IAAI,GAAGD,mBAAO,CAAC,kBAAM,CAAC;AAC5B,MAAME,EAAE,GAAGF,mBAAO,CAAC,cAAI,CAAC;AAExB,MAAMG,QAAQ,GAAGH,mBAAO,CAAC,kEAAgB,CAAC;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;EACJI,SAAS;EACTC,sBAAsB;EACtBC,eAAe;EACfC;AACF,CAAC,GAAGP,mBAAO,CAAC,6DAA0B,CAAC;AAEvC,MAAM;EACJQ,oBAAoB;EACpBC,mBAAmB;EACnBC;AACF,CAAC,GAAGV,mBAAO,CAAC,+CAAmB,CAAC;AAEhC,MAAM;EACJW;AACF,CAAC,GAAGX,mBAAO,CAAC,iFAAyB,CAAC;AAGtC,MAAM;EACJY,gBAAgB;EAChBC;AACF,CAAC,GAAGb,mBAAO,CAAC,qEAAmB,CAAC;AAEhC,MAAM;EAAEc;AAAsB,CAAC,GAAGd,mBAAO,CAAC,2FAA8B,CAAC;AAEzE,MAAM;EAAEe;AAAmB,CAAC,GAAGf,mBAAO,CAAC,2FAA8B,CAAC;;AAItE;AACA,IAAIgB,UAAU,GAAG,CAAC;AAClBJ,gBAAgB,CAAEK,MAAM,IAAK;EAC3BD,UAAU,GAAGC,MAAM;EACnBC,OAAO,CAACC,GAAG,CAAC,eAAe,EAAEH,UAAU,CAAC;AAC1C,CAAC,CAAC;AAEF,SAASI,kBAAkBA,CAACC,SAAS,EAAE;EACrC;EACA,OAAOnB,EAAE,CAACoB,WAAW,CAACD,SAAS,CAAC,CAACE,IAAI,CAAEC,IAAI,IAAKA,IAAI,CAACC,QAAQ,CAAC,GAAG,CAAC,CAAC;AACrE;AAEA,eAAeC,qBAAqBA,CAACL,SAAS,EAAE;EAC9C;EACA,OAAO,CAACD,kBAAkB,CAACC,SAAS,CAAC,EAAE;IACrCH,OAAO,CAACC,GAAG,CAAC,gCAAgC,EAAEE,SAAS,CAAC;IACxD,MAAM,IAAIM,OAAO,CAAEC,OAAO,IAAKC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;EAC7D;AACF;;AAEA;AACA;;AAEA;;AAEA,MAAME,QAAQ,GAAG/B,GAAG,CAACgC,UAAU,CAAC,CAAC,CAAC,CAAC;;AAEnC,eAAeC,aAAaA,CAACX,SAAS,EAAE;EACtC,MAAMY,QAAQ,GAAG/B,EAAE,CAChBoB,WAAW,CAACD,SAAS,CAAC,CACtBa,MAAM,CAAEV,IAAI,IAAKvB,IAAI,CAACkC,OAAO,CAACX,IAAI,CAAC,KAAK,MAAM,IAAIA,IAAI,CAACC,QAAQ,CAAC,MAAM,CAAC,CAAC;EAE3E,KAAK,MAAMW,OAAO,IAAIH,QAAQ,EAAE;IAC9B;IACA,IAAII,aAAa,GAAGD,OAAO,CAACE,OAAO,CAAC,MAAM,EAAE,MAAM,CAAC;;IAEnD;IACA,IAAIC,MAAM,GAAGrC,EAAE,CAACsC,YAAY,CAACvC,IAAI,CAACwC,IAAI,CAACpB,SAAS,EAAEgB,aAAa,CAAC,EAAE,MAAM,CAAC;IACzE,MAAMK,IAAI,GAAGlC,oBAAoB,CAAC+B,MAAM,CAAC;IACzC,MAAMI,IAAI,GAAGlC,mBAAmB,CAACiC,IAAI,CAAC;IACtC,MAAME,KAAK,GAAGlC,oBAAoB,CAACgC,IAAI,CAAC;IAExCxB,OAAO,CAACC,GAAG,CAAC,WAAW,EAAEkB,aAAa,CAAC;IAEvC,MAAMQ,MAAM,GAAG5C,IAAI,CAACwC,IAAI,CACtBX,QAAQ,EACP,UAASvB,mBAAmB,CAAC8B,aAAa,CAAE,IAAGM,IAAK,IAAGC,KAAM,KAChE,CAAC;IACD1B,OAAO,CAACC,GAAG,CAAC,SAAS,EAACR,iBAAiB,CAAC;IAExC,IAAI,CAACT,EAAE,CAAC4C,UAAU,CAACD,MAAM,CAAC,EAAE;MAC1B3C,EAAE,CAAC6C,aAAa,CAACF,MAAM,EAAE,EAAE,CAAC,CAAC,CAAC;IAChC;;IAEA;IACA,IAAIG,SAAS,GAAG9C,EAAE,CAACsC,YAAY,CAACvC,IAAI,CAACwC,IAAI,CAACpB,SAAS,EAAEe,OAAO,CAAC,EAAE,MAAM,CAAC;IACtE,IAAIa,UAAU,GAAG3C,eAAe,CAACiC,MAAM,EAAEvB,UAAU,CAAC;;IAEpD;IACA,IAAI;MACF,MAAMD,kBAAkB,CAAGkC,UAAU,EAAEJ,MAAM,CAAC;MAC7C;IACH,CAAC,CAAC,OAAOK,KAAK,EAAE;MACdhC,OAAO,CAACgC,KAAK,CAAC,WAAW,EAAEA,KAAK,CAAC;IACnC;IAEA,IAAI;MACF,MAAMpC,qBAAqB,CACzBT,sBAAsB,CAACD,SAAS,CAAC4C,SAAS,CAAC,CAAC,EAC5ChC,UAAU,EACV6B,MACF,CAAC;MACD;IACF,CAAC,CAAC,OAAOK,KAAK,EAAE,CAAC;;IAEjB;;IAEA;;IAEAhC,OAAO,CAACC,GAAG,CAAC,aAAa,EAAEH,UAAU,CAAC;;IAEtC;;IAEAA,UAAU,EAAE;EACd;EAEAH,sBAAsB,CAACG,UAAU,CAAC;EAClCE,OAAO,CAACC,GAAG,CAAC,aAAa,CAAC;;EAG1B;EACA,MAAMgC,QAAQ,GAAGlD,IAAI,CAACwC,IAAI,CACxBX,QAAQ,EAAE,SACZ,CAAC;EACD;EACA,MAAMsB,QAAQ,GAAG,MAAMzC,iBAAiB,CAACwC,QAAQ,CAAC;EAClD;AAIF;;AAIAE,MAAM,CAACC,OAAO,GAAG;EACftB;AACF,CAAC;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC7KA,MAAM9B,EAAE,GAAGF,mBAAO,CAAC,cAAI,CAAC;AACxB,MAAMC,IAAI,GAAGD,mBAAO,CAAC,kBAAM,CAAC;AAC5B,MAAMG,QAAQ,GAAGH,mBAAO,CAAC,kEAAgB,CAAC;AAE1C,eAAeW,iBAAiBA,CAAC4C,YAAY,EAAE;EAC7C,MAAMC,KAAK,GAAGtD,EAAE,CAACoB,WAAW,CAACiC,YAAY,CAAC;EAC1C,MAAME,MAAM,GAAG,EAAE;EAEjB,KAAK,MAAMjC,IAAI,IAAIgC,KAAK,EAAE;IACxB,MAAME,QAAQ,GAAGzD,IAAI,CAACwC,IAAI,CAACc,YAAY,EAAE/B,IAAI,CAAC;IAC9C,IAAItB,EAAE,CAACyD,QAAQ,CAACD,QAAQ,CAAC,CAACE,MAAM,CAAC,CAAC,EAAE;MAClC,MAAMC,EAAE,GAAG,IAAI1D,QAAQ,CAACuD,QAAQ,EAAE;QAAEI,OAAO,EAAE5C,OAAO,CAACC;MAAI,CAAC,CAAC;MAC3D,MAAM4C,IAAI,GAAGF,EAAE,CAACG,OAAO,CAAC,kDAAkD,CAAC;MAC3E,MAAMC,IAAI,GAAGF,IAAI,CAACG,GAAG,CAAC,CAAC;MAEvBT,MAAM,CAACU,IAAI,CAAC;QACV;QACAC,IAAI,EAAEH;MACR,CAAC,CAAC;MACF/C,OAAO,CAACC,GAAG,CAAC,eAAe,EAAC8C,IAAI,CAAC;MAEjCJ,EAAE,CAACQ,KAAK,CAAC,CAAC;IACZ;EACF;EAEA,OAAOZ,MAAM;AACf;AAGAJ,MAAM,CAACC,OAAO,GAAG;EACf3C;AACF,CAAC;;;;;;;;;;AC/BD,MAAM2D,SAAS,GAAGtE,mBAAO,CAAC,0CAAM,CAAC;AAEjC,SAASY,gBAAgBA,CAAC2D,QAAQ,EAAE;EAClC;EACA,MAAMC,GAAG,GAAG,IAAIF,SAAS,CAAC;IAAEG,QAAQ,EAAE,mCAAmC;IAAEC,QAAQ,EAAE;EAAK,CAAC,CAAC;;EAE5F;EACAF,GAAG,CAACG,OAAO,CAAC,CAAC,CAAC,EAAE,CAACC,GAAG,EAAEC,GAAG,KAAK;IAC5B,IAAID,GAAG,EAAE;MACP1D,OAAO,CAACgC,KAAK,CAAC,0BAA0B,EAAE0B,GAAG,CAAC;MAC9C;IACF;IACA,IAAI3D,MAAM,GAAG,CAAC;;IAEd;IACA,IAAI4D,GAAG,EAAE;MACP5D,MAAM,GAAG4D,GAAG,CAAC5D,MAAM;IACrB;;IAEA;IACA,IAAI,OAAOsD,QAAQ,KAAK,UAAU,EAAE;MAClCA,QAAQ,CAACtD,MAAM,CAAC;IAClB;EACF,CAAC,CAAC;AACJ;AAGE,SAASJ,sBAAsBA,CAACI,MAAM,EAAE;EACtC;EACA,MAAM6D,iBAAiB,GAAG7D,MAAM;;EAEhC;EACA,MAAMuD,GAAG,GAAG,IAAIF,SAAS,CAAC;IAAEG,QAAQ,EAAE,mCAAmC;IAAEC,QAAQ,EAAE;EAAK,CAAC,CAAC;;EAE5F;EACAF,GAAG,CAACO,MAAM,CAAC,CAAC,CAAC,EAAE;IAAE9D,MAAM,EAAE6D;EAAkB,CAAC,EAAE;IAAEE,MAAM,EAAE;EAAK,CAAC,EAAE,CAACJ,GAAG,EAAEK,WAAW,KAAK;IACpF,IAAIL,GAAG,EAAE;MACP1D,OAAO,CAACgC,KAAK,CAAC,gCAAgC,EAAE0B,GAAG,CAAC;MACpD;IACF;IACA1D,OAAO,CAACC,GAAG,CAAC,qBAAqB,EAAE2D,iBAAiB,CAAC;EACvD,CAAC,CAAC;AACJ;AAGFzB,MAAM,CAACC,OAAO,GAAG;EACb1C,gBAAgB;EAChBC;AACJ,CAAC;;;;;;;;;;AChDD,MAAMqE,MAAM,GAAGlF,mBAAO,CAAC,kEAAgB,CAAC;AAExC,eAAec,qBAAqBA,CAACsD,IAAI,EAAEe,MAAM,EAAEtC,MAAM,EAAE;EACzD,MAAMgB,EAAE,GAAG,IAAIqB,MAAM,CAACrC,MAAM,CAAC;EAE7B,IAAI;IACF,MAAMuC,WAAW,GAAGhB,IAAI,CAAC,CAAC,CAAC,CAACiB,KAAK,CAAC,CAAC,CAAC,CAACC,GAAG,CAAC,CAACC,UAAU,EAAEC,KAAK,KAAKD,UAAU,CAAC;IAE3E,MAAME,eAAe,GAAG5B,EAAE,CAACG,OAAO,CAAE;AACxC;AACA;AACA;AACA,UAAUoB,WAAW,CAACE,GAAG,CAACI,MAAM,IAAK,GAAEA,MAAO,OAAM,CAAC,CAACjD,IAAI,CAAC,IAAI,CAAE;AACjE;AACA,KAAK,CAAC;IAEFgD,eAAe,CAACE,GAAG,CAAC,CAAC;IAErB,MAAMC,UAAU,GAAG/B,EAAE,CAACG,OAAO,CAAE;AACnC,wCAAwCoB,WAAW,CAAC3C,IAAI,CAAC,IAAI,CAAE;AAC/D,mBAAmBoD,KAAK,CAACT,WAAW,CAACU,MAAM,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC,CAACtD,IAAI,CAAC,IAAI,CAAE;AAClE,KAAK,CAAC;IAEFoB,EAAE,CAACmC,WAAW,CAAC,MAAM;MACnB5B,IAAI,CAAC6B,OAAO,CAAC,CAACC,GAAG,EAAEV,KAAK,KAAK;QAC3B,MAAMW,WAAW,GAAGC,QAAQ,CAACF,GAAG,EAAEf,MAAM,CAAC;QACzC,MAAMkB,YAAY,GAAG,CAAClB,MAAM,EAAE,GAAGgB,WAAW,CAACd,KAAK,CAAC,CAAC,CAAC,CAACC,GAAG,CAACgB,KAAK,IAAIA,KAAK,KAAKC,SAAS,GAAGD,KAAK,GAAG,IAAI,CAAC,CAAC;QACvGpF,OAAO,CAACC,GAAG,CAAC,EAAE,CAAC;QAEf,IAAIqE,KAAK,KAAK,CAAC,EAAE,CAEjB,CAAC,MAAK,IAAIa,YAAY,CAACP,MAAM,KAAKV,WAAW,CAACU,MAAM,GAAG,CAAC,EAAE;UACxDF,UAAU,CAACD,GAAG,CAACU,YAAY,CAAC;QAC9B,CAAC,MAAM;UACL;UACA;QAAA;MAEJ,CAAC,CAAC;IACJ,CAAC,CAAC,CAAC,CAAC;EAEN,CAAC,CAAC,OAAOnD,KAAK,EAAE;IACdhC,OAAO,CAACgC,KAAK,CAAC,wCAAwC,EAAEA,KAAK,CAAC;IAC9D,MAAMA,KAAK;EACb,CAAC,SAAS;IACRW,EAAE,CAACQ,KAAK,CAAC,CAAC;EACZ;AACF;AAEA,SAAS+B,QAAQA,CAACF,GAAG,EAAEf,MAAM,EAAE;EAC7B,MAAMqB,QAAQ,GAAG,CAACrB,MAAM,CAAC;EAEzB,MAAMsB,UAAU,GAAGP,GAAG,CAACb,KAAK,CAAC,CAAC,CAAC;EAC/B,KAAK,IAAIG,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGiB,UAAU,CAACX,MAAM,EAAEN,KAAK,EAAE,EAAE;IACtDgB,QAAQ,CAACrC,IAAI,CAACsC,UAAU,CAACjB,KAAK,CAAC,CAAC;EAClC;EAEA,OAAOgB,QAAQ;AACjB;AAEAnD,MAAM,CAACC,OAAO,GAAG;EACfxC;AACF,CAAC;;;;;;;;;;AC7DD,MAAMoE,MAAM,GAAGlF,mBAAO,CAAC,kEAAgB,CAAC;;AAExC;AACA,eAAee,kBAAkBA,CAACkC,UAAU,EAAEJ,MAAM,EAAE;EACpD,MAAMgB,EAAE,GAAG,IAAIqB,MAAM,CAACrC,MAAM,CAAC;EAE7B,IAAI;IACF;IACA,MAAMuC,WAAW,GAAGsB,MAAM,CAACC,IAAI,CAAC1D,UAAU,CAAC,CAACf,MAAM,CAC/C0E,GAAG,IAAKA,GAAG,KAAK,UACnB,CAAC;;IAED;IACA,MAAMC,aAAa,GAAGzB,WAAW,CAAC3C,IAAI,CAAC,IAAI,CAAC;;IAE5C;IACA,MAAM4D,YAAY,GAAGjB,WAAW,CAACE,GAAG,CAAEsB,GAAG,IAAK3D,UAAU,CAAC2D,GAAG,CAAC,CAAC;;IAE9D;IACA,MAAMnB,eAAe,GAAG5B,EAAE,CAACG,OAAO,CAAE;AACxC;AACA;AACA,UAAUoB,WAAW,CAACE,GAAG,CAAC,CAACwB,GAAG,EAAEtB,KAAK,KAAM,GAAEsB,GAAI,OAAM,CAAC,CAACrE,IAAI,CAAC,IAAI,CAAE;AACpE;AACA,KAAK,CAAC;;IAEF;IACAgD,eAAe,CAACE,GAAG,CAAC,CAAC;IAErB,MAAMC,UAAU,GAAG/B,EAAE,CAACG,OAAO,CAAE;AACnC,2BAA2B6C,aAAc,aAAYhB,KAAK,CAACkB,IAAI,CACzD;MAAEjB,MAAM,EAAEV,WAAW,CAACU;IAAO,CAAC,EAC9B,MAAM,GACR,CAAC,CAACrD,IAAI,CAAC,IAAI,CAAE;AACjB,KAAK,CAAC;;IAEF;IACAoB,EAAE,CAACmC,WAAW,CAAC,MAAM;MACnBJ,UAAU,CAACD,GAAG,CAAC,GAAGU,YAAY,CAAC;IACjC,CAAC,CAAC,CAAC,CAAC;EACN,CAAC,CAAC,OAAOnD,KAAK,EAAE;IACdhC,OAAO,CAACgC,KAAK,CAAC,wCAAwC,EAAEA,KAAK,CAAC;IAC9D,MAAMA,KAAK;EACb,CAAC,SAAS;IACRW,EAAE,CAACQ,KAAK,CAAC,CAAC;EACZ;AACF;AAEAhB,MAAM,CAACC,OAAO,GAAG;EACfvC;AACF,CAAC;;;;;;;;;;AClDD,MAAMuD,SAAS,GAAGtE,mBAAO,CAAC,0CAAM,CAAC;AAEjC,MAAM;EAAEgH;AAAwB,CAAC,GAAGhH,mBAAO,CAAC,qDAAgB,CAAC;AAI7D,eAAeiH,2BAA2BA,CAAA,EAAG;EAC3C,IAAI;IACF;IACA,MAAMC,kBAAkB,GAAG,MAAMF,uBAAuB,CAAC,CAAC;IAC1D;IACA,MAAMG,kBAAkB,GAAG,MAAMC,wBAAwB,CAAGF,kBAAkB,CAACG,mBAAoB,CAAC;IACpG;IACA,OAAOF,kBAAkB;EAC3B,CAAC,CAAC,OAAOjE,KAAK,EAAE;IACdhC,OAAO,CAACgC,KAAK,CAAC,QAAQ,EAAEA,KAAK,CAAC;IAC9B,OAAO;MAAEA;IAAM,CAAC;EAClB;AACF;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAekE,wBAAwBA,CAACE,OAAO,EAAE;EAC/C,MAAMC,QAAQ,GAAGD,OAAO,CAAChC,GAAG,CAAEzC,MAAM,IAAK;IACvC,OAAO,IAAIlB,OAAO,CAAC,CAACC,OAAO,EAAE4F,MAAM,KAAK;MACtC,MAAM3D,EAAE,GAAG,IAAIS,SAAS,CAAC;QAAEG,QAAQ,EAAE5B,MAAM;QAAE6B,QAAQ,EAAE;MAAK,CAAC,CAAC;MAC9Db,EAAE,CAAC4D,IAAI,CAAC,CAAC,CAAC,EAAE;QAAE/E,IAAI,EAAE,CAAC;QAAEgF,IAAI,EAAE,CAAC;QAAEvC,MAAM,EAAE,CAAC;QAAEwC,GAAG,EAAE;MAAE,CAAC,EAAE,CAAC/C,GAAG,EAAEgD,SAAS,KAAK;QACvE,IAAIhD,GAAG,EAAE;UACP1D,OAAO,CAACgC,KAAK,CAAC,sCAAsC,EAAE0B,GAAG,CAAC;UAC1DhD,OAAO,CAAC;YAAGiB,MAAM;YAAEK,KAAK,EAAE0B;UAAI,CAAC,CAAC;QAClC,CAAC,MAAM;UACL;UACA,MAAMiD,kBAAkB,GAAG;YACzBC,KAAK,EAAE,EAAE;YACTC,KAAK,EAAE,EAAE;YACTC,OAAO,EAAE,EAAE;YACX/H,IAAI,EAAE;UACR,CAAC;;UAED;UACA,KAAK,MAAMgI,QAAQ,IAAIL,SAAS,EAAE;YAChC,IAAIK,QAAQ,CAACvF,IAAI,IAAIuF,QAAQ,CAACP,IAAI,IAAIO,QAAQ,CAAC9C,MAAM,EAAE;cACrD0C,kBAAkB,CAACC,KAAK,CAAC3D,IAAI,CAAC8D,QAAQ,CAACvF,IAAI,CAAC;cAC5CmF,kBAAkB,CAACE,KAAK,CAAC5D,IAAI,CAAC8D,QAAQ,CAACP,IAAI,CAAC;cAC5CG,kBAAkB,CAACG,OAAO,CAAC7D,IAAI,CAAC8D,QAAQ,CAAC9C,MAAM,CAAC;cAChD0C,kBAAkB,CAAC5H,IAAI,CAACkE,IAAI,CAACtB,MAAM,CAAC;YACtC;UACF;;UAEA;UACA;AACV;AACA;AACA;;UAEUjB,OAAO,CAAC;YACNiB,MAAM;YACNuB,IAAI,EAAEyD;UACR,CAAC,CAAC;QACJ;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC,CAAC;EAEF,IAAI;IACF,MAAMK,UAAU,GAAG,MAAMvG,OAAO,CAACuC,GAAG,CAACqD,QAAQ,CAAC;IAC9C,OAAOW,UAAU;EACnB,CAAC,CAAC,OAAOhF,KAAK,EAAE;IACdhC,OAAO,CAACgC,KAAK,CAAC,wCAAwC,EAAEA,KAAK,CAAC;IAC9D,OAAO,EAAE;EACX;AACF;AAEAG,MAAM,CAACC,OAAO,GAAG;EACf8D,wBAAwB;EACxBH;AACF,CAAC;;AAED;;;;;;;;;;AC9FA,MAAM/G,EAAE,GAAGF,mBAAO,CAAC,cAAI,CAAC;AACxB,MAAMC,IAAI,GAAGD,mBAAO,CAAC,kBAAM,CAAC;;AAE5B;AACA,SAASgH,uBAAuBA,CAAA,EAAG;EAC/B,OAAO,IAAIrF,OAAO,CAAC,CAACC,OAAO,EAAE4F,MAAM,KAAK;IACtC,MAAMW,UAAU,GAAG,QAAQ;IAC3B,MAAMd,mBAAmB,GAAG,EAAE;;IAE9B;IACAnH,EAAE,CAACkI,OAAO,CAACD,UAAU,EAAE,CAACvD,GAAG,EAAE3C,QAAQ,KAAK;MACxC,IAAI2C,GAAG,EAAE;QACP1D,OAAO,CAACgC,KAAK,CAAC,8BAA8B,EAAE0B,GAAG,CAAC;QAClD4C,MAAM,CAAC5C,GAAG,CAAC;MACb,CAAC,MAAM;QACL;QACA3C,QAAQ,CAACgE,OAAO,CAAE7D,OAAO,IAAK;UAC5B;UACA,MAAMiG,WAAW,GAAGpI,IAAI,CAACwC,IAAI,CAAC0F,UAAU,EAAE/F,OAAO,CAAC;UAClDlC,EAAE,CAACoI,IAAI,CAACD,WAAW,EAAE,CAACzD,GAAG,EAAE2D,KAAK,KAAK;YACnC,IAAI3D,GAAG,EAAE;cACP1D,OAAO,CAACgC,KAAK,CAAC,2CAA2C,EAAE0B,GAAG,CAAC;YACjE,CAAC,MAAM;cACL,IAAI2D,KAAK,CAAC3E,MAAM,CAAC,CAAC,EAAE;gBAClByD,mBAAmB,CAAClD,IAAI,CAACgE,UAAU,GAAC,GAAG,GAAC/F,OAAO,CAAC,CAAC,CAAC;cACpD;YACF;;YAEA;YACA,IAAIiF,mBAAmB,CAACvB,MAAM,KAAK7D,QAAQ,CAAC6D,MAAM,EAAE;cAClD,MAAMoC,UAAU,GAAG;gBACjBb;cACF,CAAC;cACDzF,OAAO,CAACsG,UAAU,CAAC;YACrB;UACF,CAAC,CAAC;QACJ,CAAC,CAAC;MACJ;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;AAEA,SAASM,iBAAiBA,CAACC,UAAU,EAAE;EACrC,IAAI;IACF,MAAMF,KAAK,GAAGrI,EAAE,CAACyD,QAAQ,CAAC8E,UAAU,CAAC;IACrC,OAAOF,KAAK,CAACG,WAAW,CAAC,CAAC;EAC5B,CAAC,CAAC,OAAOxF,KAAK,EAAE;IACd,IAAIA,KAAK,CAACyF,IAAI,KAAK,QAAQ,EAAE;MAC3B,OAAO,KAAK,CAAC,CAAC;IAChB;;IACA,MAAMzF,KAAK,CAAC,CAAC;EACf;AACF;;AAGFG,MAAM,CAACC,OAAO,GAAG;EACb0D;AAEF,CAAC;;;;;;;;;;AC1DH,SAAS5G,SAASA,CAACwI,IAAI,EAAE;EACvB,MAAM3E,IAAI,GAAG2E,IAAI,CAACC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;EAC/B,MAAMpF,MAAM,GAAG,EAAE,CAAC,CAAC;;EAEnB,KAAK,IAAIqF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7E,IAAI,CAAC6B,MAAM,EAAEgD,CAAC,EAAE,EAAE;IACpC,MAAMC,OAAO,GAAG9E,IAAI,CAAC6E,CAAC,CAAC,CAACD,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;IACrC,MAAMG,aAAa,GAAGD,OAAO,CAAC1D,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC4D,MAAM,CAACF,OAAO,CAAC1D,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IACvE5B,MAAM,CAACU,IAAI,CAAC6E,aAAa,CAAC,CAAC,CAAC;EAC9B;;EAEA,OAAOvF,MAAM,CAAC,CAAC;AACjB;;AAEA,SAASnD,eAAeA,CAACsI,IAAI,EAAEzD,MAAM,EAAE;EACrC;EACA;;EAEA;EACA,IAAIlB,IAAI,GAAG2E,IAAI,CAACC,KAAK,CAAC,IAAI,CAAC;;EAE3B;EACA5E,IAAI,GAAGA,IAAI,CAACqB,GAAG,CAAEY,GAAG,IAAKA,GAAG,CAAC5D,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;EAEvD,MAAM4G,qBAAqB,GAAG,CAAC,CAAC;;EAEhC;EACA,MAAMC,aAAa,GAAG,CACpB,UAAU,EACV,QAAQ,EACR,MAAM,EACN,MAAM,EACN,OAAO,EACP,aAAa,EACb,OAAO,EACP,sBAAsB,CACvB;EAED,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7E,IAAI,CAAC6B,MAAM,GAAG,CAAC,EAAEgD,CAAC,EAAE,EAAE;IACxC,MAAMC,OAAO,GAAG9E,IAAI,CAAC6E,CAAC,CAAC,CAACD,KAAK,CAAC,IAAI,CAAC;IACnC,MAAMO,cAAc,GAAGnF,IAAI,CAAC6E,CAAC,GAAG,CAAC,CAAC,CAACD,KAAK,CAAC,IAAI,CAAC;IAE9C,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,OAAO,CAACjD,MAAM,EAAEuD,CAAC,EAAE,EAAE;MACvC,MAAMC,OAAO,GAAGP,OAAO,CAACM,CAAC,CAAC;MAE1B,IAAIF,aAAa,CAAC1H,QAAQ,CAAC6H,OAAO,CAAC,EAAE;QACnC,MAAMC,KAAK,GAAGH,cAAc,CAACC,CAAC,CAAC;QAC/BH,qBAAqB,CAACI,OAAO,CAAC,GAAGC,KAAK;MACxC;IACF;EACF;;EAEA;EACAL,qBAAqB,CAAC,QAAQ,CAAC,GAAG/D,MAAM;EACxC;EACA;EACA;EACA,OAAO+D,qBAAqB;AAC9B;AAEA,SAASM,yBAAyBA,CAACZ,IAAI,EAAEa,OAAO,EAAE;EAChD,MAAMxF,IAAI,GAAG2E,IAAI,CAACC,KAAK,CAAC,IAAI,CAAC;EAE7B,IAAI5E,IAAI,CAAC6B,MAAM,IAAI,CAAC,EAAE;IACpB,MAAMiD,OAAO,GAAG9E,IAAI,CAAC,CAAC,CAAC,CAAC4E,KAAK,CAAC,IAAI,CAAC;IAEnC,IAAIE,OAAO,CAACjD,MAAM,IAAI,CAAC,EAAE;MACvB;MACA,OAAOiD,OAAO,CAACU,OAAO,CAAC,CAAC,CAAC;IAC3B;EACF;;EAEA,OAAO,IAAI,CAAC,CAAC;AACf;;AAEA,SAASpJ,sBAAsBA,CAAC+D,IAAI,EAAE;EACpC,MAAMsF,OAAO,GAAG,EAAE;EAIlB,KAAK,IAAIZ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG1E,IAAI,CAAC0B,MAAM,EAAEgD,CAAC,EAAE,EAAE;IACpC,MAAM5C,GAAG,GAAG9B,IAAI,CAAC0E,CAAC,CAAC;IACnB,MAAMa,MAAM,GAAGzD,GAAG,CAACb,KAAK,CAAC,CAAC;IAE1B,KAAK,IAAIgE,CAAC,GAAGM,MAAM,CAAC7D,MAAM,GAAG,CAAC,EAAEuD,CAAC,GAAGM,MAAM,CAAC7D,MAAM,EAAEuD,CAAC,EAAE,EAAE;MACtD,MAAM/C,KAAK,GAAGqD,MAAM,CAACN,CAAC,CAAC;MAEvB,IAAI,CAACO,KAAK,CAACC,MAAM,CAACvD,KAAK,CAAC,CAAC,EAAE;QACzB,MAAMwD,WAAW,GAAGD,MAAM,CAACvD,KAAK,CAAC,CAACyD,OAAO,CAAC,CAAC,CAAC;QAC5CJ,MAAM,CAACN,CAAC,CAAC,GAAGS,WAAW,CAACE,QAAQ,CAAC,CAAC;MACpC;;MAGA;MACA,IAAIL,MAAM,CAACN,CAAC,CAAC,KAAK,IAAI,EAAE;QACtBM,MAAM,CAACN,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC;MAE/B;IAEF;;IAIAK,OAAO,CAACvF,IAAI,CAACwF,MAAM,CAAC;EACtB;EACC;EACD,OAAOD,OAAO;AAChB;;AAEA;;AAEA,SAASnJ,mBAAmBA,CAAC0J,KAAK,EAAE;EAClC,MAAMC,eAAe,GAAGD,KAAK,CAACE,OAAO,CAAC,GAAG,CAAC;EAC1C,IAAID,eAAe,KAAK,CAAC,CAAC,EAAE;IAC1B,OAAOD,KAAK,CAAC5E,KAAK,CAAC,CAAC,EAAE6E,eAAe,CAAC;EACxC,CAAC,MAAM;IACL,OAAOD,KAAK;EACd;AACF;AAEA5G,MAAM,CAACC,OAAO,GAAG;EACf/C,mBAAmB;EACnBH,SAAS;EACTC,sBAAsB;EACtBC,eAAe;EACfkJ;AACF,CAAC;;;;;;;;;;AC5HC;AACF,SAAS/I,mBAAmBA,CAAC2J,KAAK,EAAE;EAChC,MAAMC,MAAM,GAAGD,KAAK,CAACvB,KAAK,CAAC,GAAG,CAAC;EAC/B,OAAOwB,MAAM,CAAC,CAAC,CAAC;AAClB;;AAEA;AACA,SAAS3J,oBAAoBA,CAAC0J,KAAK,EAAE;EACnC,MAAMC,MAAM,GAAGD,KAAK,CAACvB,KAAK,CAAC,GAAG,CAAC;EAC/B,OAAOwB,MAAM,CAAC,CAAC,CAAC;AAClB;AAGA,SAAS7J,oBAAoBA,CAACoI,IAAI,EAAE;EAClC,MAAM3E,IAAI,GAAG2E,IAAI,CAACC,KAAK,CAAC,IAAI,CAAC;EAE7B,IAAI5E,IAAI,CAAC6B,MAAM,IAAI,CAAC,EAAE;IACpB,MAAMiD,OAAO,GAAG9E,IAAI,CAAC,CAAC,CAAC,CAAC4E,KAAK,CAAC,IAAI,CAAC;IAEnC,IAAIE,OAAO,CAACjD,MAAM,IAAI,CAAC,EAAE;MACvB;MACA,OAAOiD,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;IACrB;EACF;;EAEA,OAAO,IAAI,CAAC,CAAC;AACf;;AAEA1F,MAAM,CAACC,OAAO,GAAG;EACf9C,oBAAoB;EACpBC,mBAAmB;EACnBC;AAGF,CAAC;;;;;;;;;;;ACnCH;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;ACtBA,MAAM;EAAEX,GAAG;EAAEuK;AAAc,CAAC,GAAGtK,mBAAO,CAAC,0BAAU,CAAC;AAElD,MAAM;EAAEuK;AAAQ,CAAC,GAAGvK,mBAAO,CAAC,0BAAU,CAAC;AAEvC,MAAM;EAAEgC;AAAc,CAAC,GAAGhC,mBAAO,CAAC,2EAA+B,CAAC;AAElE,MAAM;EAAEiH;AAA4B,CAAC,GAAGjH,mBAAO,CAAC,+EAAiC,CAAC;;AAElF;;AAEA,MAAMwK,YAAY,GAAGA,CAAA,KAAM;EACzB;EACA,MAAMC,UAAU,GAAG,IAAIH,aAAa,CAAC;IACnCI,KAAK,EAAE,GAAG;IACVC,MAAM,EAAE,GAAG;IACXC,cAAc,EAAE;MACd;MACAC,OAAO,EAAEC,yHAAiCA;IAC5C;EACF,CAAC,CAAC;;EAEF;EACAL,UAAU,CAACM,OAAO,CAACC,mCAAyB,CAAC;;EAE7C;EACAP,UAAU,CAACQ,WAAW,CAACC,YAAY,CAAC,CAAC;AACvC,CAAC;;AAED;AACA;AACA;AACAnL,GAAG,CAACoL,EAAE,CAAC,OAAO,EAAEX,YAAY,CAAC;;AAE7B;AACA;AACA;AACAzK,GAAG,CAACoL,EAAE,CAAC,mBAAmB,EAAE,MAAM;EAChC,IAAIC,OAAO,CAACC,QAAQ,KAAK,QAAQ,EAAE;IACjCtL,GAAG,CAACuL,IAAI,CAAC,CAAC;EACZ;AACF,CAAC,CAAC;AAEFvL,GAAG,CAACoL,EAAE,CAAC,UAAU,EAAE,MAAM;EACvB;EACA;EACA,IAAIb,aAAa,CAACiB,aAAa,CAAC,CAAC,CAACzF,MAAM,KAAK,CAAC,EAAE;IAC9C0E,YAAY,CAAC,CAAC;EAChB;AACF,CAAC,CAAC;;AAEF;AACA;;AAEA;AACAD,OAAO,CAACY,EAAE,CAAC,WAAW,EAAE,CAACK,KAAK,EAAEnK,SAAS,KAAK;EAC5CW,aAAa,CAACX,SAAS,CAAC;EACxBH,OAAO,CAACC,GAAG,CAAC,YAAY,EAAEE,SAAS,CAAC;AACtC,CAAC,CAAC;AAOFkJ,OAAO,CAACY,EAAE,CAAC,kBAAkB,EAAE,MAAOK,KAAK,IAAK;EAE/C,MAAMvE,2BAA2B,CAAC,CAAC,CAACwE,IAAI,CAAEC,oBAAoB,IAAK;IAChE;IACAF,KAAK,CAACG,MAAM,CAACC,IAAI,CAAC,wCAAwC,EAAEF,oBAAoB,CAAC;EACnF,CAAC,CAAC,CACDG,KAAK,CAAE3I,KAAK,IAAK;IAEhBhC,OAAO,CAACgC,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;EACrD,CAAC,CAAC;AAGJ,CAAC,CAAC;;AAOF;AACA,SAAS4I,gBAAgBA,CAAA,EAAG;EAC1B,OAAO,IAAInK,OAAO,CAAEC,OAAO,IAAK;IAC9B;IACA;IACAA,OAAO,CAAC,oCAAoC,CAAC;IAC7C;EACF,CAAC,CAAC;AACJ;;AAGA2I,OAAO,CAACY,EAAE,CAAC,iBAAiB,EAAE,MAAOK,KAAK,IAAK;EAC7C,IAAI;IACF,MAAMO,OAAO,GAAG,MAAMD,gBAAgB,CAAC,CAAC;IACxCN,KAAK,CAACG,MAAM,CAACC,IAAI,CAAC,oBAAoB,EAAEG,OAAO,CAAC;EAClD,CAAC,CAAC,OAAO7I,KAAK,EAAE;IACd;IACAsI,KAAK,CAACG,MAAM,CAACC,IAAI,CAAC,oBAAoB,EAAE,6BAA6B,CAAC;EACxE;AACF,CAAC,CAAC,C","sources":["webpack://my-app/./node_modules/async/lib/async.js","webpack://my-app/./node_modules/better-sqlite3/lib/database.js","webpack://my-app/./node_modules/better-sqlite3/lib/index.js","webpack://my-app/./node_modules/better-sqlite3/lib/methods/aggregate.js","webpack://my-app/./node_modules/better-sqlite3/lib/methods/backup.js","webpack://my-app/./node_modules/better-sqlite3/lib/methods/function.js","webpack://my-app/./node_modules/better-sqlite3/lib/methods/inspect.js","webpack://my-app/./node_modules/better-sqlite3/lib/methods/pragma.js","webpack://my-app/./node_modules/better-sqlite3/lib/methods/serialize.js","webpack://my-app/./node_modules/better-sqlite3/lib/methods/table.js","webpack://my-app/./node_modules/better-sqlite3/lib/methods/transaction.js","webpack://my-app/./node_modules/better-sqlite3/lib/methods/wrappers.js","webpack://my-app/./node_modules/better-sqlite3/lib/sqlite-error.js","webpack://my-app/./node_modules/better-sqlite3/lib/util.js","webpack://my-app/./node_modules/binary-search-tree/index.js","webpack://my-app/./node_modules/binary-search-tree/lib/avltree.js","webpack://my-app/./node_modules/binary-search-tree/lib/bst.js","webpack://my-app/./node_modules/binary-search-tree/lib/customUtils.js","webpack://my-app/./node_modules/mkdirp/index.js","webpack://my-app/./node_modules/nedb/index.js","webpack://my-app/./node_modules/nedb/lib/cursor.js","webpack://my-app/./node_modules/nedb/lib/customUtils.js","webpack://my-app/./node_modules/nedb/lib/datastore.js","webpack://my-app/./node_modules/nedb/lib/executor.js","webpack://my-app/./node_modules/nedb/lib/indexes.js","webpack://my-app/./node_modules/nedb/lib/model.js","webpack://my-app/./node_modules/nedb/lib/persistence.js","webpack://my-app/./node_modules/nedb/lib/storage.js","webpack://my-app/./node_modules/underscore/underscore.js","webpack://my-app/./src/services/database/FilesToDb.js","webpack://my-app/./src/services/database/LoadDatabase_BSQLITE3.js","webpack://my-app/./src/services/database/PartnBToDB_NEDB.js","webpack://my-app/./src/services/database/SaveCHRtoDatabase_BSQLITE3.js","webpack://my-app/./src/services/database/SaveHDRtoDatabase_BSQLITE3.js","webpack://my-app/./src/services/database/loadDB_NEDB.js","webpack://my-app/./src/services/files/files.js","webpack://my-app/./src/utils/TextFormater.js","webpack://my-app/./src/utils/fecha.js","webpack://my-app/external node-commonjs \"crypto\"","webpack://my-app/external node-commonjs \"electron\"","webpack://my-app/external node-commonjs \"events\"","webpack://my-app/external node-commonjs \"fs\"","webpack://my-app/external node-commonjs \"path\"","webpack://my-app/external node-commonjs \"util\"","webpack://my-app/webpack/bootstrap","webpack://my-app/./src/main.js"],"sourcesContent":["/*global setImmediate: false, setTimeout: false, console: false */\n(function () {\n  var async = {};\n\n  // global on the server, window in the browser\n  var root, previous_async;\n  root = this;\n  if (root != null) {\n    previous_async = root.async;\n  }\n  async.noConflict = function () {\n    root.async = previous_async;\n    return async;\n  };\n  function only_once(fn) {\n    var called = false;\n    return function () {\n      if (called) throw new Error(\"Callback was already called.\");\n      called = true;\n      fn.apply(root, arguments);\n    };\n  }\n\n  //// cross-browser compatiblity functions ////\n\n  var _each = function (arr, iterator) {\n    if (arr.forEach) {\n      return arr.forEach(iterator);\n    }\n    for (var i = 0; i < arr.length; i += 1) {\n      iterator(arr[i], i, arr);\n    }\n  };\n  var _map = function (arr, iterator) {\n    if (arr.map) {\n      return arr.map(iterator);\n    }\n    var results = [];\n    _each(arr, function (x, i, a) {\n      results.push(iterator(x, i, a));\n    });\n    return results;\n  };\n  var _reduce = function (arr, iterator, memo) {\n    if (arr.reduce) {\n      return arr.reduce(iterator, memo);\n    }\n    _each(arr, function (x, i, a) {\n      memo = iterator(memo, x, i, a);\n    });\n    return memo;\n  };\n  var _keys = function (obj) {\n    if (Object.keys) {\n      return Object.keys(obj);\n    }\n    var keys = [];\n    for (var k in obj) {\n      if (obj.hasOwnProperty(k)) {\n        keys.push(k);\n      }\n    }\n    return keys;\n  };\n\n  //// exported async module functions ////\n\n  //// nextTick implementation with browser-compatible fallback ////\n  if (typeof process === 'undefined' || !process.nextTick) {\n    if (typeof setImmediate === 'function') {\n      async.nextTick = function (fn) {\n        // not a direct alias for IE10 compatibility\n        setImmediate(fn);\n      };\n      async.setImmediate = async.nextTick;\n    } else {\n      async.nextTick = function (fn) {\n        setTimeout(fn, 0);\n      };\n      async.setImmediate = async.nextTick;\n    }\n  } else {\n    async.nextTick = process.nextTick;\n    if (typeof setImmediate !== 'undefined') {\n      async.setImmediate = function (fn) {\n        // not a direct alias for IE10 compatibility\n        setImmediate(fn);\n      };\n    } else {\n      async.setImmediate = async.nextTick;\n    }\n  }\n  async.each = function (arr, iterator, callback) {\n    callback = callback || function () {};\n    if (!arr.length) {\n      return callback();\n    }\n    var completed = 0;\n    _each(arr, function (x) {\n      iterator(x, only_once(function (err) {\n        if (err) {\n          callback(err);\n          callback = function () {};\n        } else {\n          completed += 1;\n          if (completed >= arr.length) {\n            callback(null);\n          }\n        }\n      }));\n    });\n  };\n  async.forEach = async.each;\n  async.eachSeries = function (arr, iterator, callback) {\n    callback = callback || function () {};\n    if (!arr.length) {\n      return callback();\n    }\n    var completed = 0;\n    var iterate = function () {\n      iterator(arr[completed], function (err) {\n        if (err) {\n          callback(err);\n          callback = function () {};\n        } else {\n          completed += 1;\n          if (completed >= arr.length) {\n            callback(null);\n          } else {\n            iterate();\n          }\n        }\n      });\n    };\n    iterate();\n  };\n  async.forEachSeries = async.eachSeries;\n  async.eachLimit = function (arr, limit, iterator, callback) {\n    var fn = _eachLimit(limit);\n    fn.apply(null, [arr, iterator, callback]);\n  };\n  async.forEachLimit = async.eachLimit;\n  var _eachLimit = function (limit) {\n    return function (arr, iterator, callback) {\n      callback = callback || function () {};\n      if (!arr.length || limit <= 0) {\n        return callback();\n      }\n      var completed = 0;\n      var started = 0;\n      var running = 0;\n      (function replenish() {\n        if (completed >= arr.length) {\n          return callback();\n        }\n        while (running < limit && started < arr.length) {\n          started += 1;\n          running += 1;\n          iterator(arr[started - 1], function (err) {\n            if (err) {\n              callback(err);\n              callback = function () {};\n            } else {\n              completed += 1;\n              running -= 1;\n              if (completed >= arr.length) {\n                callback();\n              } else {\n                replenish();\n              }\n            }\n          });\n        }\n      })();\n    };\n  };\n  var doParallel = function (fn) {\n    return function () {\n      var args = Array.prototype.slice.call(arguments);\n      return fn.apply(null, [async.each].concat(args));\n    };\n  };\n  var doParallelLimit = function (limit, fn) {\n    return function () {\n      var args = Array.prototype.slice.call(arguments);\n      return fn.apply(null, [_eachLimit(limit)].concat(args));\n    };\n  };\n  var doSeries = function (fn) {\n    return function () {\n      var args = Array.prototype.slice.call(arguments);\n      return fn.apply(null, [async.eachSeries].concat(args));\n    };\n  };\n  var _asyncMap = function (eachfn, arr, iterator, callback) {\n    var results = [];\n    arr = _map(arr, function (x, i) {\n      return {\n        index: i,\n        value: x\n      };\n    });\n    eachfn(arr, function (x, callback) {\n      iterator(x.value, function (err, v) {\n        results[x.index] = v;\n        callback(err);\n      });\n    }, function (err) {\n      callback(err, results);\n    });\n  };\n  async.map = doParallel(_asyncMap);\n  async.mapSeries = doSeries(_asyncMap);\n  async.mapLimit = function (arr, limit, iterator, callback) {\n    return _mapLimit(limit)(arr, iterator, callback);\n  };\n  var _mapLimit = function (limit) {\n    return doParallelLimit(limit, _asyncMap);\n  };\n\n  // reduce only has a series version, as doing reduce in parallel won't\n  // work in many situations.\n  async.reduce = function (arr, memo, iterator, callback) {\n    async.eachSeries(arr, function (x, callback) {\n      iterator(memo, x, function (err, v) {\n        memo = v;\n        callback(err);\n      });\n    }, function (err) {\n      callback(err, memo);\n    });\n  };\n  // inject alias\n  async.inject = async.reduce;\n  // foldl alias\n  async.foldl = async.reduce;\n  async.reduceRight = function (arr, memo, iterator, callback) {\n    var reversed = _map(arr, function (x) {\n      return x;\n    }).reverse();\n    async.reduce(reversed, memo, iterator, callback);\n  };\n  // foldr alias\n  async.foldr = async.reduceRight;\n  var _filter = function (eachfn, arr, iterator, callback) {\n    var results = [];\n    arr = _map(arr, function (x, i) {\n      return {\n        index: i,\n        value: x\n      };\n    });\n    eachfn(arr, function (x, callback) {\n      iterator(x.value, function (v) {\n        if (v) {\n          results.push(x);\n        }\n        callback();\n      });\n    }, function (err) {\n      callback(_map(results.sort(function (a, b) {\n        return a.index - b.index;\n      }), function (x) {\n        return x.value;\n      }));\n    });\n  };\n  async.filter = doParallel(_filter);\n  async.filterSeries = doSeries(_filter);\n  // select alias\n  async.select = async.filter;\n  async.selectSeries = async.filterSeries;\n  var _reject = function (eachfn, arr, iterator, callback) {\n    var results = [];\n    arr = _map(arr, function (x, i) {\n      return {\n        index: i,\n        value: x\n      };\n    });\n    eachfn(arr, function (x, callback) {\n      iterator(x.value, function (v) {\n        if (!v) {\n          results.push(x);\n        }\n        callback();\n      });\n    }, function (err) {\n      callback(_map(results.sort(function (a, b) {\n        return a.index - b.index;\n      }), function (x) {\n        return x.value;\n      }));\n    });\n  };\n  async.reject = doParallel(_reject);\n  async.rejectSeries = doSeries(_reject);\n  var _detect = function (eachfn, arr, iterator, main_callback) {\n    eachfn(arr, function (x, callback) {\n      iterator(x, function (result) {\n        if (result) {\n          main_callback(x);\n          main_callback = function () {};\n        } else {\n          callback();\n        }\n      });\n    }, function (err) {\n      main_callback();\n    });\n  };\n  async.detect = doParallel(_detect);\n  async.detectSeries = doSeries(_detect);\n  async.some = function (arr, iterator, main_callback) {\n    async.each(arr, function (x, callback) {\n      iterator(x, function (v) {\n        if (v) {\n          main_callback(true);\n          main_callback = function () {};\n        }\n        callback();\n      });\n    }, function (err) {\n      main_callback(false);\n    });\n  };\n  // any alias\n  async.any = async.some;\n  async.every = function (arr, iterator, main_callback) {\n    async.each(arr, function (x, callback) {\n      iterator(x, function (v) {\n        if (!v) {\n          main_callback(false);\n          main_callback = function () {};\n        }\n        callback();\n      });\n    }, function (err) {\n      main_callback(true);\n    });\n  };\n  // all alias\n  async.all = async.every;\n  async.sortBy = function (arr, iterator, callback) {\n    async.map(arr, function (x, callback) {\n      iterator(x, function (err, criteria) {\n        if (err) {\n          callback(err);\n        } else {\n          callback(null, {\n            value: x,\n            criteria: criteria\n          });\n        }\n      });\n    }, function (err, results) {\n      if (err) {\n        return callback(err);\n      } else {\n        var fn = function (left, right) {\n          var a = left.criteria,\n            b = right.criteria;\n          return a < b ? -1 : a > b ? 1 : 0;\n        };\n        callback(null, _map(results.sort(fn), function (x) {\n          return x.value;\n        }));\n      }\n    });\n  };\n  async.auto = function (tasks, callback) {\n    callback = callback || function () {};\n    var keys = _keys(tasks);\n    if (!keys.length) {\n      return callback(null);\n    }\n    var results = {};\n    var listeners = [];\n    var addListener = function (fn) {\n      listeners.unshift(fn);\n    };\n    var removeListener = function (fn) {\n      for (var i = 0; i < listeners.length; i += 1) {\n        if (listeners[i] === fn) {\n          listeners.splice(i, 1);\n          return;\n        }\n      }\n    };\n    var taskComplete = function () {\n      _each(listeners.slice(0), function (fn) {\n        fn();\n      });\n    };\n    addListener(function () {\n      if (_keys(results).length === keys.length) {\n        callback(null, results);\n        callback = function () {};\n      }\n    });\n    _each(keys, function (k) {\n      var task = tasks[k] instanceof Function ? [tasks[k]] : tasks[k];\n      var taskCallback = function (err) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        if (args.length <= 1) {\n          args = args[0];\n        }\n        if (err) {\n          var safeResults = {};\n          _each(_keys(results), function (rkey) {\n            safeResults[rkey] = results[rkey];\n          });\n          safeResults[k] = args;\n          callback(err, safeResults);\n          // stop subsequent errors hitting callback multiple times\n          callback = function () {};\n        } else {\n          results[k] = args;\n          async.setImmediate(taskComplete);\n        }\n      };\n      var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n      var ready = function () {\n        return _reduce(requires, function (a, x) {\n          return a && results.hasOwnProperty(x);\n        }, true) && !results.hasOwnProperty(k);\n      };\n      if (ready()) {\n        task[task.length - 1](taskCallback, results);\n      } else {\n        var listener = function () {\n          if (ready()) {\n            removeListener(listener);\n            task[task.length - 1](taskCallback, results);\n          }\n        };\n        addListener(listener);\n      }\n    });\n  };\n  async.waterfall = function (tasks, callback) {\n    callback = callback || function () {};\n    if (tasks.constructor !== Array) {\n      var err = new Error('First argument to waterfall must be an array of functions');\n      return callback(err);\n    }\n    if (!tasks.length) {\n      return callback();\n    }\n    var wrapIterator = function (iterator) {\n      return function (err) {\n        if (err) {\n          callback.apply(null, arguments);\n          callback = function () {};\n        } else {\n          var args = Array.prototype.slice.call(arguments, 1);\n          var next = iterator.next();\n          if (next) {\n            args.push(wrapIterator(next));\n          } else {\n            args.push(callback);\n          }\n          async.setImmediate(function () {\n            iterator.apply(null, args);\n          });\n        }\n      };\n    };\n    wrapIterator(async.iterator(tasks))();\n  };\n  var _parallel = function (eachfn, tasks, callback) {\n    callback = callback || function () {};\n    if (tasks.constructor === Array) {\n      eachfn.map(tasks, function (fn, callback) {\n        if (fn) {\n          fn(function (err) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            if (args.length <= 1) {\n              args = args[0];\n            }\n            callback.call(null, err, args);\n          });\n        }\n      }, callback);\n    } else {\n      var results = {};\n      eachfn.each(_keys(tasks), function (k, callback) {\n        tasks[k](function (err) {\n          var args = Array.prototype.slice.call(arguments, 1);\n          if (args.length <= 1) {\n            args = args[0];\n          }\n          results[k] = args;\n          callback(err);\n        });\n      }, function (err) {\n        callback(err, results);\n      });\n    }\n  };\n  async.parallel = function (tasks, callback) {\n    _parallel({\n      map: async.map,\n      each: async.each\n    }, tasks, callback);\n  };\n  async.parallelLimit = function (tasks, limit, callback) {\n    _parallel({\n      map: _mapLimit(limit),\n      each: _eachLimit(limit)\n    }, tasks, callback);\n  };\n  async.series = function (tasks, callback) {\n    callback = callback || function () {};\n    if (tasks.constructor === Array) {\n      async.mapSeries(tasks, function (fn, callback) {\n        if (fn) {\n          fn(function (err) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            if (args.length <= 1) {\n              args = args[0];\n            }\n            callback.call(null, err, args);\n          });\n        }\n      }, callback);\n    } else {\n      var results = {};\n      async.eachSeries(_keys(tasks), function (k, callback) {\n        tasks[k](function (err) {\n          var args = Array.prototype.slice.call(arguments, 1);\n          if (args.length <= 1) {\n            args = args[0];\n          }\n          results[k] = args;\n          callback(err);\n        });\n      }, function (err) {\n        callback(err, results);\n      });\n    }\n  };\n  async.iterator = function (tasks) {\n    var makeCallback = function (index) {\n      var fn = function () {\n        if (tasks.length) {\n          tasks[index].apply(null, arguments);\n        }\n        return fn.next();\n      };\n      fn.next = function () {\n        return index < tasks.length - 1 ? makeCallback(index + 1) : null;\n      };\n      return fn;\n    };\n    return makeCallback(0);\n  };\n  async.apply = function (fn) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function () {\n      return fn.apply(null, args.concat(Array.prototype.slice.call(arguments)));\n    };\n  };\n  var _concat = function (eachfn, arr, fn, callback) {\n    var r = [];\n    eachfn(arr, function (x, cb) {\n      fn(x, function (err, y) {\n        r = r.concat(y || []);\n        cb(err);\n      });\n    }, function (err) {\n      callback(err, r);\n    });\n  };\n  async.concat = doParallel(_concat);\n  async.concatSeries = doSeries(_concat);\n  async.whilst = function (test, iterator, callback) {\n    if (test()) {\n      iterator(function (err) {\n        if (err) {\n          return callback(err);\n        }\n        async.whilst(test, iterator, callback);\n      });\n    } else {\n      callback();\n    }\n  };\n  async.doWhilst = function (iterator, test, callback) {\n    iterator(function (err) {\n      if (err) {\n        return callback(err);\n      }\n      if (test()) {\n        async.doWhilst(iterator, test, callback);\n      } else {\n        callback();\n      }\n    });\n  };\n  async.until = function (test, iterator, callback) {\n    if (!test()) {\n      iterator(function (err) {\n        if (err) {\n          return callback(err);\n        }\n        async.until(test, iterator, callback);\n      });\n    } else {\n      callback();\n    }\n  };\n  async.doUntil = function (iterator, test, callback) {\n    iterator(function (err) {\n      if (err) {\n        return callback(err);\n      }\n      if (!test()) {\n        async.doUntil(iterator, test, callback);\n      } else {\n        callback();\n      }\n    });\n  };\n  async.queue = function (worker, concurrency) {\n    if (concurrency === undefined) {\n      concurrency = 1;\n    }\n    function _insert(q, data, pos, callback) {\n      if (data.constructor !== Array) {\n        data = [data];\n      }\n      _each(data, function (task) {\n        var item = {\n          data: task,\n          callback: typeof callback === 'function' ? callback : null\n        };\n        if (pos) {\n          q.tasks.unshift(item);\n        } else {\n          q.tasks.push(item);\n        }\n        if (q.saturated && q.tasks.length === concurrency) {\n          q.saturated();\n        }\n        async.setImmediate(q.process);\n      });\n    }\n    var workers = 0;\n    var q = {\n      tasks: [],\n      concurrency: concurrency,\n      saturated: null,\n      empty: null,\n      drain: null,\n      push: function (data, callback) {\n        _insert(q, data, false, callback);\n      },\n      unshift: function (data, callback) {\n        _insert(q, data, true, callback);\n      },\n      process: function () {\n        if (workers < q.concurrency && q.tasks.length) {\n          var task = q.tasks.shift();\n          if (q.empty && q.tasks.length === 0) {\n            q.empty();\n          }\n          workers += 1;\n          var next = function () {\n            workers -= 1;\n            if (task.callback) {\n              task.callback.apply(task, arguments);\n            }\n            if (q.drain && q.tasks.length + workers === 0) {\n              q.drain();\n            }\n            q.process();\n          };\n          var cb = only_once(next);\n          worker(task.data, cb);\n        }\n      },\n      length: function () {\n        return q.tasks.length;\n      },\n      running: function () {\n        return workers;\n      }\n    };\n    return q;\n  };\n  async.cargo = function (worker, payload) {\n    var working = false,\n      tasks = [];\n    var cargo = {\n      tasks: tasks,\n      payload: payload,\n      saturated: null,\n      empty: null,\n      drain: null,\n      push: function (data, callback) {\n        if (data.constructor !== Array) {\n          data = [data];\n        }\n        _each(data, function (task) {\n          tasks.push({\n            data: task,\n            callback: typeof callback === 'function' ? callback : null\n          });\n          if (cargo.saturated && tasks.length === payload) {\n            cargo.saturated();\n          }\n        });\n        async.setImmediate(cargo.process);\n      },\n      process: function process() {\n        if (working) return;\n        if (tasks.length === 0) {\n          if (cargo.drain) cargo.drain();\n          return;\n        }\n        var ts = typeof payload === 'number' ? tasks.splice(0, payload) : tasks.splice(0);\n        var ds = _map(ts, function (task) {\n          return task.data;\n        });\n        if (cargo.empty) cargo.empty();\n        working = true;\n        worker(ds, function () {\n          working = false;\n          var args = arguments;\n          _each(ts, function (data) {\n            if (data.callback) {\n              data.callback.apply(null, args);\n            }\n          });\n          process();\n        });\n      },\n      length: function () {\n        return tasks.length;\n      },\n      running: function () {\n        return working;\n      }\n    };\n    return cargo;\n  };\n  var _console_fn = function (name) {\n    return function (fn) {\n      var args = Array.prototype.slice.call(arguments, 1);\n      fn.apply(null, args.concat([function (err) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        if (typeof console !== 'undefined') {\n          if (err) {\n            if (console.error) {\n              console.error(err);\n            }\n          } else if (console[name]) {\n            _each(args, function (x) {\n              console[name](x);\n            });\n          }\n        }\n      }]));\n    };\n  };\n  async.log = _console_fn('log');\n  async.dir = _console_fn('dir');\n  /*async.info = _console_fn('info');\n  async.warn = _console_fn('warn');\n  async.error = _console_fn('error');*/\n\n  async.memoize = function (fn, hasher) {\n    var memo = {};\n    var queues = {};\n    hasher = hasher || function (x) {\n      return x;\n    };\n    var memoized = function () {\n      var args = Array.prototype.slice.call(arguments);\n      var callback = args.pop();\n      var key = hasher.apply(null, args);\n      if (key in memo) {\n        callback.apply(null, memo[key]);\n      } else if (key in queues) {\n        queues[key].push(callback);\n      } else {\n        queues[key] = [callback];\n        fn.apply(null, args.concat([function () {\n          memo[key] = arguments;\n          var q = queues[key];\n          delete queues[key];\n          for (var i = 0, l = q.length; i < l; i++) {\n            q[i].apply(null, arguments);\n          }\n        }]));\n      }\n    };\n    memoized.memo = memo;\n    memoized.unmemoized = fn;\n    return memoized;\n  };\n  async.unmemoize = function (fn) {\n    return function () {\n      return (fn.unmemoized || fn).apply(null, arguments);\n    };\n  };\n  async.times = function (count, iterator, callback) {\n    var counter = [];\n    for (var i = 0; i < count; i++) {\n      counter.push(i);\n    }\n    return async.map(counter, iterator, callback);\n  };\n  async.timesSeries = function (count, iterator, callback) {\n    var counter = [];\n    for (var i = 0; i < count; i++) {\n      counter.push(i);\n    }\n    return async.mapSeries(counter, iterator, callback);\n  };\n  async.compose = function /* functions... */\n  () {\n    var fns = Array.prototype.reverse.call(arguments);\n    return function () {\n      var that = this;\n      var args = Array.prototype.slice.call(arguments);\n      var callback = args.pop();\n      async.reduce(fns, args, function (newargs, fn, cb) {\n        fn.apply(that, newargs.concat([function () {\n          var err = arguments[0];\n          var nextargs = Array.prototype.slice.call(arguments, 1);\n          cb(err, nextargs);\n        }]));\n      }, function (err, results) {\n        callback.apply(that, [err].concat(results));\n      });\n    };\n  };\n  var _applyEach = function (eachfn, fns /*args...*/) {\n    var go = function () {\n      var that = this;\n      var args = Array.prototype.slice.call(arguments);\n      var callback = args.pop();\n      return eachfn(fns, function (fn, cb) {\n        fn.apply(that, args.concat([cb]));\n      }, callback);\n    };\n    if (arguments.length > 2) {\n      var args = Array.prototype.slice.call(arguments, 2);\n      return go.apply(this, args);\n    } else {\n      return go;\n    }\n  };\n  async.applyEach = doParallel(_applyEach);\n  async.applyEachSeries = doSeries(_applyEach);\n  async.forever = function (fn, callback) {\n    function next(err) {\n      if (err) {\n        if (callback) {\n          return callback(err);\n        }\n        throw err;\n      }\n      fn(next);\n    }\n    next();\n  };\n\n  // AMD / RequireJS\n  if (typeof define !== 'undefined' && define.amd) {\n    define([], function () {\n      return async;\n    });\n  }\n  // Node.js\n  else if (typeof module !== 'undefined' && module.exports) {\n    module.exports = async;\n  }\n  // included directly via <script> tag\n  else {\n    root.async = async;\n  }\n})();",null,"'use strict';\n\nmodule.exports = require('./database');\nmodule.exports.SqliteError = require('./sqlite-error');","'use strict';\n\nconst {\n  getBooleanOption,\n  cppdb\n} = require('../util');\nmodule.exports = function defineAggregate(name, options) {\n  // Validate arguments\n  if (typeof name !== 'string') throw new TypeError('Expected first argument to be a string');\n  if (typeof options !== 'object' || options === null) throw new TypeError('Expected second argument to be an options object');\n  if (!name) throw new TypeError('User-defined function name cannot be an empty string');\n\n  // Interpret options\n  const start = 'start' in options ? options.start : null;\n  const step = getFunctionOption(options, 'step', true);\n  const inverse = getFunctionOption(options, 'inverse', false);\n  const result = getFunctionOption(options, 'result', false);\n  const safeIntegers = 'safeIntegers' in options ? +getBooleanOption(options, 'safeIntegers') : 2;\n  const deterministic = getBooleanOption(options, 'deterministic');\n  const directOnly = getBooleanOption(options, 'directOnly');\n  const varargs = getBooleanOption(options, 'varargs');\n  let argCount = -1;\n\n  // Determine argument count\n  if (!varargs) {\n    argCount = Math.max(getLength(step), inverse ? getLength(inverse) : 0);\n    if (argCount > 0) argCount -= 1;\n    if (argCount > 100) throw new RangeError('User-defined functions cannot have more than 100 arguments');\n  }\n  this[cppdb].aggregate(start, step, inverse, result, name, argCount, safeIntegers, deterministic, directOnly);\n  return this;\n};\nconst getFunctionOption = (options, key, required) => {\n  const value = key in options ? options[key] : null;\n  if (typeof value === 'function') return value;\n  if (value != null) throw new TypeError(`Expected the \"${key}\" option to be a function`);\n  if (required) throw new TypeError(`Missing required option \"${key}\"`);\n  return null;\n};\nconst getLength = ({\n  length\n}) => {\n  if (Number.isInteger(length) && length >= 0) return length;\n  throw new TypeError('Expected function.length to be a positive integer');\n};","'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst {\n  promisify\n} = require('util');\nconst {\n  cppdb\n} = require('../util');\nconst fsAccess = promisify(fs.access);\nmodule.exports = async function backup(filename, options) {\n  if (options == null) options = {};\n\n  // Validate arguments\n  if (typeof filename !== 'string') throw new TypeError('Expected first argument to be a string');\n  if (typeof options !== 'object') throw new TypeError('Expected second argument to be an options object');\n\n  // Interpret options\n  filename = filename.trim();\n  const attachedName = 'attached' in options ? options.attached : 'main';\n  const handler = 'progress' in options ? options.progress : null;\n\n  // Validate interpreted options\n  if (!filename) throw new TypeError('Backup filename cannot be an empty string');\n  if (filename === ':memory:') throw new TypeError('Invalid backup filename \":memory:\"');\n  if (typeof attachedName !== 'string') throw new TypeError('Expected the \"attached\" option to be a string');\n  if (!attachedName) throw new TypeError('The \"attached\" option cannot be an empty string');\n  if (handler != null && typeof handler !== 'function') throw new TypeError('Expected the \"progress\" option to be a function');\n\n  // Make sure the specified directory exists\n  await fsAccess(path.dirname(filename)).catch(() => {\n    throw new TypeError('Cannot save backup because the directory does not exist');\n  });\n  const isNewFile = await fsAccess(filename).then(() => false, () => true);\n  return runBackup(this[cppdb].backup(this, attachedName, filename, isNewFile), handler || null);\n};\nconst runBackup = (backup, handler) => {\n  let rate = 0;\n  let useDefault = true;\n  return new Promise((resolve, reject) => {\n    setImmediate(function step() {\n      try {\n        const progress = backup.transfer(rate);\n        if (!progress.remainingPages) {\n          backup.close();\n          resolve(progress);\n          return;\n        }\n        if (useDefault) {\n          useDefault = false;\n          rate = 100;\n        }\n        if (handler) {\n          const ret = handler(progress);\n          if (ret !== undefined) {\n            if (typeof ret === 'number' && ret === ret) rate = Math.max(0, Math.min(0x7fffffff, Math.round(ret)));else throw new TypeError('Expected progress callback to return a number or undefined');\n          }\n        }\n        setImmediate(step);\n      } catch (err) {\n        backup.close();\n        reject(err);\n      }\n    });\n  });\n};","'use strict';\n\nconst {\n  getBooleanOption,\n  cppdb\n} = require('../util');\nmodule.exports = function defineFunction(name, options, fn) {\n  // Apply defaults\n  if (options == null) options = {};\n  if (typeof options === 'function') {\n    fn = options;\n    options = {};\n  }\n\n  // Validate arguments\n  if (typeof name !== 'string') throw new TypeError('Expected first argument to be a string');\n  if (typeof fn !== 'function') throw new TypeError('Expected last argument to be a function');\n  if (typeof options !== 'object') throw new TypeError('Expected second argument to be an options object');\n  if (!name) throw new TypeError('User-defined function name cannot be an empty string');\n\n  // Interpret options\n  const safeIntegers = 'safeIntegers' in options ? +getBooleanOption(options, 'safeIntegers') : 2;\n  const deterministic = getBooleanOption(options, 'deterministic');\n  const directOnly = getBooleanOption(options, 'directOnly');\n  const varargs = getBooleanOption(options, 'varargs');\n  let argCount = -1;\n\n  // Determine argument count\n  if (!varargs) {\n    argCount = fn.length;\n    if (!Number.isInteger(argCount) || argCount < 0) throw new TypeError('Expected function.length to be a positive integer');\n    if (argCount > 100) throw new RangeError('User-defined functions cannot have more than 100 arguments');\n  }\n  this[cppdb].function(fn, name, argCount, safeIntegers, deterministic, directOnly);\n  return this;\n};","'use strict';\n\nconst DatabaseInspection = function Database() {};\nmodule.exports = function inspect(depth, opts) {\n  return Object.assign(new DatabaseInspection(), this);\n};","'use strict';\n\nconst {\n  getBooleanOption,\n  cppdb\n} = require('../util');\nmodule.exports = function pragma(source, options) {\n  if (options == null) options = {};\n  if (typeof source !== 'string') throw new TypeError('Expected first argument to be a string');\n  if (typeof options !== 'object') throw new TypeError('Expected second argument to be an options object');\n  const simple = getBooleanOption(options, 'simple');\n  const stmt = this[cppdb].prepare(`PRAGMA ${source}`, this, true);\n  return simple ? stmt.pluck().get() : stmt.all();\n};","'use strict';\n\nconst {\n  cppdb\n} = require('../util');\nmodule.exports = function serialize(options) {\n  if (options == null) options = {};\n\n  // Validate arguments\n  if (typeof options !== 'object') throw new TypeError('Expected first argument to be an options object');\n\n  // Interpret and validate options\n  const attachedName = 'attached' in options ? options.attached : 'main';\n  if (typeof attachedName !== 'string') throw new TypeError('Expected the \"attached\" option to be a string');\n  if (!attachedName) throw new TypeError('The \"attached\" option cannot be an empty string');\n  return this[cppdb].serialize(attachedName);\n};","'use strict';\n\nconst {\n  cppdb\n} = require('../util');\nmodule.exports = function defineTable(name, factory) {\n  // Validate arguments\n  if (typeof name !== 'string') throw new TypeError('Expected first argument to be a string');\n  if (!name) throw new TypeError('Virtual table module name cannot be an empty string');\n\n  // Determine whether the module is eponymous-only or not\n  let eponymous = false;\n  if (typeof factory === 'object' && factory !== null) {\n    eponymous = true;\n    factory = defer(parseTableDefinition(factory, 'used', name));\n  } else {\n    if (typeof factory !== 'function') throw new TypeError('Expected second argument to be a function or a table definition object');\n    factory = wrapFactory(factory);\n  }\n  this[cppdb].table(factory, name, eponymous);\n  return this;\n};\nfunction wrapFactory(factory) {\n  return function virtualTableFactory(moduleName, databaseName, tableName, ...args) {\n    const thisObject = {\n      module: moduleName,\n      database: databaseName,\n      table: tableName\n    };\n\n    // Generate a new table definition by invoking the factory\n    const def = apply.call(factory, thisObject, args);\n    if (typeof def !== 'object' || def === null) {\n      throw new TypeError(`Virtual table module \"${moduleName}\" did not return a table definition object`);\n    }\n    return parseTableDefinition(def, 'returned', moduleName);\n  };\n}\nfunction parseTableDefinition(def, verb, moduleName) {\n  // Validate required properties\n  if (!hasOwnProperty.call(def, 'rows')) {\n    throw new TypeError(`Virtual table module \"${moduleName}\" ${verb} a table definition without a \"rows\" property`);\n  }\n  if (!hasOwnProperty.call(def, 'columns')) {\n    throw new TypeError(`Virtual table module \"${moduleName}\" ${verb} a table definition without a \"columns\" property`);\n  }\n\n  // Validate \"rows\" property\n  const rows = def.rows;\n  if (typeof rows !== 'function' || Object.getPrototypeOf(rows) !== GeneratorFunctionPrototype) {\n    throw new TypeError(`Virtual table module \"${moduleName}\" ${verb} a table definition with an invalid \"rows\" property (should be a generator function)`);\n  }\n\n  // Validate \"columns\" property\n  let columns = def.columns;\n  if (!Array.isArray(columns) || !(columns = [...columns]).every(x => typeof x === 'string')) {\n    throw new TypeError(`Virtual table module \"${moduleName}\" ${verb} a table definition with an invalid \"columns\" property (should be an array of strings)`);\n  }\n  if (columns.length !== new Set(columns).size) {\n    throw new TypeError(`Virtual table module \"${moduleName}\" ${verb} a table definition with duplicate column names`);\n  }\n  if (!columns.length) {\n    throw new RangeError(`Virtual table module \"${moduleName}\" ${verb} a table definition with zero columns`);\n  }\n\n  // Validate \"parameters\" property\n  let parameters;\n  if (hasOwnProperty.call(def, 'parameters')) {\n    parameters = def.parameters;\n    if (!Array.isArray(parameters) || !(parameters = [...parameters]).every(x => typeof x === 'string')) {\n      throw new TypeError(`Virtual table module \"${moduleName}\" ${verb} a table definition with an invalid \"parameters\" property (should be an array of strings)`);\n    }\n  } else {\n    parameters = inferParameters(rows);\n  }\n  if (parameters.length !== new Set(parameters).size) {\n    throw new TypeError(`Virtual table module \"${moduleName}\" ${verb} a table definition with duplicate parameter names`);\n  }\n  if (parameters.length > 32) {\n    throw new RangeError(`Virtual table module \"${moduleName}\" ${verb} a table definition with more than the maximum number of 32 parameters`);\n  }\n  for (const parameter of parameters) {\n    if (columns.includes(parameter)) {\n      throw new TypeError(`Virtual table module \"${moduleName}\" ${verb} a table definition with column \"${parameter}\" which was ambiguously defined as both a column and parameter`);\n    }\n  }\n\n  // Validate \"safeIntegers\" option\n  let safeIntegers = 2;\n  if (hasOwnProperty.call(def, 'safeIntegers')) {\n    const bool = def.safeIntegers;\n    if (typeof bool !== 'boolean') {\n      throw new TypeError(`Virtual table module \"${moduleName}\" ${verb} a table definition with an invalid \"safeIntegers\" property (should be a boolean)`);\n    }\n    safeIntegers = +bool;\n  }\n\n  // Validate \"directOnly\" option\n  let directOnly = false;\n  if (hasOwnProperty.call(def, 'directOnly')) {\n    directOnly = def.directOnly;\n    if (typeof directOnly !== 'boolean') {\n      throw new TypeError(`Virtual table module \"${moduleName}\" ${verb} a table definition with an invalid \"directOnly\" property (should be a boolean)`);\n    }\n  }\n\n  // Generate SQL for the virtual table definition\n  const columnDefinitions = [...parameters.map(identifier).map(str => `${str} HIDDEN`), ...columns.map(identifier)];\n  return [`CREATE TABLE x(${columnDefinitions.join(', ')});`, wrapGenerator(rows, new Map(columns.map((x, i) => [x, parameters.length + i])), moduleName), parameters, safeIntegers, directOnly];\n}\nfunction wrapGenerator(generator, columnMap, moduleName) {\n  return function* virtualTable(...args) {\n    /*\n    \tWe must defensively clone any buffers in the arguments, because\n    \totherwise the generator could mutate one of them, which would cause\n    \tus to return incorrect values for hidden columns, potentially\n    \tcorrupting the database.\n     */\n    const output = args.map(x => Buffer.isBuffer(x) ? Buffer.from(x) : x);\n    for (let i = 0; i < columnMap.size; ++i) {\n      output.push(null); // Fill with nulls to prevent gaps in array (v8 optimization)\n    }\n\n    for (const row of generator(...args)) {\n      if (Array.isArray(row)) {\n        extractRowArray(row, output, columnMap.size, moduleName);\n        yield output;\n      } else if (typeof row === 'object' && row !== null) {\n        extractRowObject(row, output, columnMap, moduleName);\n        yield output;\n      } else {\n        throw new TypeError(`Virtual table module \"${moduleName}\" yielded something that isn't a valid row object`);\n      }\n    }\n  };\n}\nfunction extractRowArray(row, output, columnCount, moduleName) {\n  if (row.length !== columnCount) {\n    throw new TypeError(`Virtual table module \"${moduleName}\" yielded a row with an incorrect number of columns`);\n  }\n  const offset = output.length - columnCount;\n  for (let i = 0; i < columnCount; ++i) {\n    output[i + offset] = row[i];\n  }\n}\nfunction extractRowObject(row, output, columnMap, moduleName) {\n  let count = 0;\n  for (const key of Object.keys(row)) {\n    const index = columnMap.get(key);\n    if (index === undefined) {\n      throw new TypeError(`Virtual table module \"${moduleName}\" yielded a row with an undeclared column \"${key}\"`);\n    }\n    output[index] = row[key];\n    count += 1;\n  }\n  if (count !== columnMap.size) {\n    throw new TypeError(`Virtual table module \"${moduleName}\" yielded a row with missing columns`);\n  }\n}\nfunction inferParameters({\n  length\n}) {\n  if (!Number.isInteger(length) || length < 0) {\n    throw new TypeError('Expected function.length to be a positive integer');\n  }\n  const params = [];\n  for (let i = 0; i < length; ++i) {\n    params.push(`$${i + 1}`);\n  }\n  return params;\n}\nconst {\n  hasOwnProperty\n} = Object.prototype;\nconst {\n  apply\n} = Function.prototype;\nconst GeneratorFunctionPrototype = Object.getPrototypeOf(function* () {});\nconst identifier = str => `\"${str.replace(/\"/g, '\"\"')}\"`;\nconst defer = x => () => x;","'use strict';\n\nconst {\n  cppdb\n} = require('../util');\nconst controllers = new WeakMap();\nmodule.exports = function transaction(fn) {\n  if (typeof fn !== 'function') throw new TypeError('Expected first argument to be a function');\n  const db = this[cppdb];\n  const controller = getController(db, this);\n  const {\n    apply\n  } = Function.prototype;\n\n  // Each version of the transaction function has these same properties\n  const properties = {\n    default: {\n      value: wrapTransaction(apply, fn, db, controller.default)\n    },\n    deferred: {\n      value: wrapTransaction(apply, fn, db, controller.deferred)\n    },\n    immediate: {\n      value: wrapTransaction(apply, fn, db, controller.immediate)\n    },\n    exclusive: {\n      value: wrapTransaction(apply, fn, db, controller.exclusive)\n    },\n    database: {\n      value: this,\n      enumerable: true\n    }\n  };\n  Object.defineProperties(properties.default.value, properties);\n  Object.defineProperties(properties.deferred.value, properties);\n  Object.defineProperties(properties.immediate.value, properties);\n  Object.defineProperties(properties.exclusive.value, properties);\n\n  // Return the default version of the transaction function\n  return properties.default.value;\n};\n\n// Return the database's cached transaction controller, or create a new one\nconst getController = (db, self) => {\n  let controller = controllers.get(db);\n  if (!controller) {\n    const shared = {\n      commit: db.prepare('COMMIT', self, false),\n      rollback: db.prepare('ROLLBACK', self, false),\n      savepoint: db.prepare('SAVEPOINT `\\t_bs3.\\t`', self, false),\n      release: db.prepare('RELEASE `\\t_bs3.\\t`', self, false),\n      rollbackTo: db.prepare('ROLLBACK TO `\\t_bs3.\\t`', self, false)\n    };\n    controllers.set(db, controller = {\n      default: Object.assign({\n        begin: db.prepare('BEGIN', self, false)\n      }, shared),\n      deferred: Object.assign({\n        begin: db.prepare('BEGIN DEFERRED', self, false)\n      }, shared),\n      immediate: Object.assign({\n        begin: db.prepare('BEGIN IMMEDIATE', self, false)\n      }, shared),\n      exclusive: Object.assign({\n        begin: db.prepare('BEGIN EXCLUSIVE', self, false)\n      }, shared)\n    });\n  }\n  return controller;\n};\n\n// Return a new transaction function by wrapping the given function\nconst wrapTransaction = (apply, fn, db, {\n  begin,\n  commit,\n  rollback,\n  savepoint,\n  release,\n  rollbackTo\n}) => function sqliteTransaction() {\n  let before, after, undo;\n  if (db.inTransaction) {\n    before = savepoint;\n    after = release;\n    undo = rollbackTo;\n  } else {\n    before = begin;\n    after = commit;\n    undo = rollback;\n  }\n  before.run();\n  try {\n    const result = apply.call(fn, this, arguments);\n    after.run();\n    return result;\n  } catch (ex) {\n    if (db.inTransaction) {\n      undo.run();\n      if (undo !== rollback) after.run();\n    }\n    throw ex;\n  }\n};","'use strict';\n\nconst {\n  cppdb\n} = require('../util');\nexports.prepare = function prepare(sql) {\n  return this[cppdb].prepare(sql, this, false);\n};\nexports.exec = function exec(sql) {\n  this[cppdb].exec(sql);\n  return this;\n};\nexports.close = function close() {\n  this[cppdb].close();\n  return this;\n};\nexports.loadExtension = function loadExtension(...args) {\n  this[cppdb].loadExtension(...args);\n  return this;\n};\nexports.defaultSafeIntegers = function defaultSafeIntegers(...args) {\n  this[cppdb].defaultSafeIntegers(...args);\n  return this;\n};\nexports.unsafeMode = function unsafeMode(...args) {\n  this[cppdb].unsafeMode(...args);\n  return this;\n};\nexports.getters = {\n  name: {\n    get: function name() {\n      return this[cppdb].name;\n    },\n    enumerable: true\n  },\n  open: {\n    get: function open() {\n      return this[cppdb].open;\n    },\n    enumerable: true\n  },\n  inTransaction: {\n    get: function inTransaction() {\n      return this[cppdb].inTransaction;\n    },\n    enumerable: true\n  },\n  readonly: {\n    get: function readonly() {\n      return this[cppdb].readonly;\n    },\n    enumerable: true\n  },\n  memory: {\n    get: function memory() {\n      return this[cppdb].memory;\n    },\n    enumerable: true\n  }\n};","'use strict';\n\nconst descriptor = {\n  value: 'SqliteError',\n  writable: true,\n  enumerable: false,\n  configurable: true\n};\nfunction SqliteError(message, code) {\n  if (new.target !== SqliteError) {\n    return new SqliteError(message, code);\n  }\n  if (typeof code !== 'string') {\n    throw new TypeError('Expected second argument to be a string');\n  }\n  Error.call(this, message);\n  descriptor.value = '' + message;\n  Object.defineProperty(this, 'message', descriptor);\n  Error.captureStackTrace(this, SqliteError);\n  this.code = code;\n}\nObject.setPrototypeOf(SqliteError, Error);\nObject.setPrototypeOf(SqliteError.prototype, Error.prototype);\nObject.defineProperty(SqliteError.prototype, 'name', descriptor);\nmodule.exports = SqliteError;","'use strict';\n\nexports.getBooleanOption = (options, key) => {\n  let value = false;\n  if (key in options && typeof (value = options[key]) !== 'boolean') {\n    throw new TypeError(`Expected the \"${key}\" option to be a boolean`);\n  }\n  return value;\n};\nexports.cppdb = Symbol();\nexports.inspect = Symbol.for('nodejs.util.inspect.custom');","module.exports.BinarySearchTree = require('./lib/bst');\nmodule.exports.AVLTree = require('./lib/avltree');","/**\n * Self-balancing binary search tree using the AVL implementation\n */\nvar BinarySearchTree = require('./bst'),\n  customUtils = require('./customUtils'),\n  util = require('util'),\n  _ = require('underscore');\n\n/**\n * Constructor\n * We can't use a direct pointer to the root node (as in the simple binary search tree)\n * as the root will change during tree rotations\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\nfunction AVLTree(options) {\n  this.tree = new _AVLTree(options);\n}\n\n/**\n * Constructor of the internal AVLTree\n * @param {Object} options Optional\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Key}      options.key Initialize this BST's key with key\n * @param {Value}    options.value Initialize this BST's data with [value]\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\nfunction _AVLTree(options) {\n  options = options || {};\n  this.left = null;\n  this.right = null;\n  this.parent = options.parent !== undefined ? options.parent : null;\n  if (options.hasOwnProperty('key')) {\n    this.key = options.key;\n  }\n  this.data = options.hasOwnProperty('value') ? [options.value] : [];\n  this.unique = options.unique || false;\n  this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;\n  this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;\n}\n\n/**\n * Inherit basic functions from the basic binary search tree\n */\nutil.inherits(_AVLTree, BinarySearchTree);\n\n/**\n * Keep a pointer to the internal tree constructor for testing purposes\n */\nAVLTree._AVLTree = _AVLTree;\n\n/**\n * Check the recorded height is correct for every node\n * Throws if one height doesn't match\n */\n_AVLTree.prototype.checkHeightCorrect = function () {\n  var leftH, rightH;\n  if (!this.hasOwnProperty('key')) {\n    return;\n  } // Empty tree\n\n  if (this.left && this.left.height === undefined) {\n    throw new Error(\"Undefined height for node \" + this.left.key);\n  }\n  if (this.right && this.right.height === undefined) {\n    throw new Error(\"Undefined height for node \" + this.right.key);\n  }\n  if (this.height === undefined) {\n    throw new Error(\"Undefined height for node \" + this.key);\n  }\n  leftH = this.left ? this.left.height : 0;\n  rightH = this.right ? this.right.height : 0;\n  if (this.height !== 1 + Math.max(leftH, rightH)) {\n    throw new Error(\"Height constraint failed for node \" + this.key);\n  }\n  if (this.left) {\n    this.left.checkHeightCorrect();\n  }\n  if (this.right) {\n    this.right.checkHeightCorrect();\n  }\n};\n\n/**\n * Return the balance factor\n */\n_AVLTree.prototype.balanceFactor = function () {\n  var leftH = this.left ? this.left.height : 0,\n    rightH = this.right ? this.right.height : 0;\n  return leftH - rightH;\n};\n\n/**\n * Check that the balance factors are all between -1 and 1\n */\n_AVLTree.prototype.checkBalanceFactors = function () {\n  if (Math.abs(this.balanceFactor()) > 1) {\n    throw new Error('Tree is unbalanced at node ' + this.key);\n  }\n  if (this.left) {\n    this.left.checkBalanceFactors();\n  }\n  if (this.right) {\n    this.right.checkBalanceFactors();\n  }\n};\n\n/**\n * When checking if the BST conditions are met, also check that the heights are correct\n * and the tree is balanced\n */\n_AVLTree.prototype.checkIsAVLT = function () {\n  _AVLTree.super_.prototype.checkIsBST.call(this);\n  this.checkHeightCorrect();\n  this.checkBalanceFactors();\n};\nAVLTree.prototype.checkIsAVLT = function () {\n  this.tree.checkIsAVLT();\n};\n\n/**\n * Perform a right rotation of the tree if possible\n * and return the root of the resulting tree\n * The resulting tree's nodes' heights are also updated\n */\n_AVLTree.prototype.rightRotation = function () {\n  var q = this,\n    p = this.left,\n    b,\n    ah,\n    bh,\n    ch;\n  if (!p) {\n    return this;\n  } // No change\n\n  b = p.right;\n\n  // Alter tree structure\n  if (q.parent) {\n    p.parent = q.parent;\n    if (q.parent.left === q) {\n      q.parent.left = p;\n    } else {\n      q.parent.right = p;\n    }\n  } else {\n    p.parent = null;\n  }\n  p.right = q;\n  q.parent = p;\n  q.left = b;\n  if (b) {\n    b.parent = q;\n  }\n\n  // Update heights\n  ah = p.left ? p.left.height : 0;\n  bh = b ? b.height : 0;\n  ch = q.right ? q.right.height : 0;\n  q.height = Math.max(bh, ch) + 1;\n  p.height = Math.max(ah, q.height) + 1;\n  return p;\n};\n\n/**\n * Perform a left rotation of the tree if possible\n * and return the root of the resulting tree\n * The resulting tree's nodes' heights are also updated\n */\n_AVLTree.prototype.leftRotation = function () {\n  var p = this,\n    q = this.right,\n    b,\n    ah,\n    bh,\n    ch;\n  if (!q) {\n    return this;\n  } // No change\n\n  b = q.left;\n\n  // Alter tree structure\n  if (p.parent) {\n    q.parent = p.parent;\n    if (p.parent.left === p) {\n      p.parent.left = q;\n    } else {\n      p.parent.right = q;\n    }\n  } else {\n    q.parent = null;\n  }\n  q.left = p;\n  p.parent = q;\n  p.right = b;\n  if (b) {\n    b.parent = p;\n  }\n\n  // Update heights\n  ah = p.left ? p.left.height : 0;\n  bh = b ? b.height : 0;\n  ch = q.right ? q.right.height : 0;\n  p.height = Math.max(ah, bh) + 1;\n  q.height = Math.max(ch, p.height) + 1;\n  return q;\n};\n\n/**\n * Modify the tree if its right subtree is too small compared to the left\n * Return the new root if any\n */\n_AVLTree.prototype.rightTooSmall = function () {\n  if (this.balanceFactor() <= 1) {\n    return this;\n  } // Right is not too small, don't change\n\n  if (this.left.balanceFactor() < 0) {\n    this.left.leftRotation();\n  }\n  return this.rightRotation();\n};\n\n/**\n * Modify the tree if its left subtree is too small compared to the right\n * Return the new root if any\n */\n_AVLTree.prototype.leftTooSmall = function () {\n  if (this.balanceFactor() >= -1) {\n    return this;\n  } // Left is not too small, don't change\n\n  if (this.right.balanceFactor() > 0) {\n    this.right.rightRotation();\n  }\n  return this.leftRotation();\n};\n\n/**\n * Rebalance the tree along the given path. The path is given reversed (as he was calculated\n * in the insert and delete functions).\n * Returns the new root of the tree\n * Of course, the first element of the path must be the root of the tree\n */\n_AVLTree.prototype.rebalanceAlongPath = function (path) {\n  var newRoot = this,\n    rotated,\n    i;\n  if (!this.hasOwnProperty('key')) {\n    delete this.height;\n    return this;\n  } // Empty tree\n\n  // Rebalance the tree and update all heights\n  for (i = path.length - 1; i >= 0; i -= 1) {\n    path[i].height = 1 + Math.max(path[i].left ? path[i].left.height : 0, path[i].right ? path[i].right.height : 0);\n    if (path[i].balanceFactor() > 1) {\n      rotated = path[i].rightTooSmall();\n      if (i === 0) {\n        newRoot = rotated;\n      }\n    }\n    if (path[i].balanceFactor() < -1) {\n      rotated = path[i].leftTooSmall();\n      if (i === 0) {\n        newRoot = rotated;\n      }\n    }\n  }\n  return newRoot;\n};\n\n/**\n * Insert a key, value pair in the tree while maintaining the AVL tree height constraint\n * Return a pointer to the root node, which may have changed\n */\n_AVLTree.prototype.insert = function (key, value) {\n  var insertPath = [],\n    currentNode = this;\n\n  // Empty tree, insert as root\n  if (!this.hasOwnProperty('key')) {\n    this.key = key;\n    this.data.push(value);\n    this.height = 1;\n    return this;\n  }\n\n  // Insert new leaf at the right place\n  while (true) {\n    // Same key: no change in the tree structure\n    if (currentNode.compareKeys(currentNode.key, key) === 0) {\n      if (currentNode.unique) {\n        var err = new Error(\"Can't insert key \" + key + \", it violates the unique constraint\");\n        err.key = key;\n        err.errorType = 'uniqueViolated';\n        throw err;\n      } else {\n        currentNode.data.push(value);\n      }\n      return this;\n    }\n    insertPath.push(currentNode);\n    if (currentNode.compareKeys(key, currentNode.key) < 0) {\n      if (!currentNode.left) {\n        insertPath.push(currentNode.createLeftChild({\n          key: key,\n          value: value\n        }));\n        break;\n      } else {\n        currentNode = currentNode.left;\n      }\n    } else {\n      if (!currentNode.right) {\n        insertPath.push(currentNode.createRightChild({\n          key: key,\n          value: value\n        }));\n        break;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n  }\n  return this.rebalanceAlongPath(insertPath);\n};\n\n// Insert in the internal tree, update the pointer to the root if needed\nAVLTree.prototype.insert = function (key, value) {\n  var newTree = this.tree.insert(key, value);\n\n  // If newTree is undefined, that means its structure was not modified\n  if (newTree) {\n    this.tree = newTree;\n  }\n};\n\n/**\n * Delete a key or just a value and return the new root of the tree\n * @param {Key} key\n * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n */\n_AVLTree.prototype.delete = function (key, value) {\n  var newData = [],\n    replaceWith,\n    self = this,\n    currentNode = this,\n    deletePath = [];\n  if (!this.hasOwnProperty('key')) {\n    return this;\n  } // Empty tree\n\n  // Either no match is found and the function will return from within the loop\n  // Or a match is found and deletePath will contain the path from the root to the node to delete after the loop\n  while (true) {\n    if (currentNode.compareKeys(key, currentNode.key) === 0) {\n      break;\n    }\n    deletePath.push(currentNode);\n    if (currentNode.compareKeys(key, currentNode.key) < 0) {\n      if (currentNode.left) {\n        currentNode = currentNode.left;\n      } else {\n        return this; // Key not found, no modification\n      }\n    } else {\n      // currentNode.compareKeys(key, currentNode.key) is > 0\n      if (currentNode.right) {\n        currentNode = currentNode.right;\n      } else {\n        return this; // Key not found, no modification\n      }\n    }\n  }\n\n  // Delete only a value (no tree modification)\n  if (currentNode.data.length > 1 && value) {\n    currentNode.data.forEach(function (d) {\n      if (!currentNode.checkValueEquality(d, value)) {\n        newData.push(d);\n      }\n    });\n    currentNode.data = newData;\n    return this;\n  }\n\n  // Delete a whole node\n\n  // Leaf\n  if (!currentNode.left && !currentNode.right) {\n    if (currentNode === this) {\n      // This leaf is also the root\n      delete currentNode.key;\n      currentNode.data = [];\n      delete currentNode.height;\n      return this;\n    } else {\n      if (currentNode.parent.left === currentNode) {\n        currentNode.parent.left = null;\n      } else {\n        currentNode.parent.right = null;\n      }\n      return this.rebalanceAlongPath(deletePath);\n    }\n  }\n\n  // Node with only one child\n  if (!currentNode.left || !currentNode.right) {\n    replaceWith = currentNode.left ? currentNode.left : currentNode.right;\n    if (currentNode === this) {\n      // This node is also the root\n      replaceWith.parent = null;\n      return replaceWith; // height of replaceWith is necessarily 1 because the tree was balanced before deletion\n    } else {\n      if (currentNode.parent.left === currentNode) {\n        currentNode.parent.left = replaceWith;\n        replaceWith.parent = currentNode.parent;\n      } else {\n        currentNode.parent.right = replaceWith;\n        replaceWith.parent = currentNode.parent;\n      }\n      return this.rebalanceAlongPath(deletePath);\n    }\n  }\n\n  // Node with two children\n  // Use the in-order predecessor (no need to randomize since we actively rebalance)\n  deletePath.push(currentNode);\n  replaceWith = currentNode.left;\n\n  // Special case: the in-order predecessor is right below the node to delete\n  if (!replaceWith.right) {\n    currentNode.key = replaceWith.key;\n    currentNode.data = replaceWith.data;\n    currentNode.left = replaceWith.left;\n    if (replaceWith.left) {\n      replaceWith.left.parent = currentNode;\n    }\n    return this.rebalanceAlongPath(deletePath);\n  }\n\n  // After this loop, replaceWith is the right-most leaf in the left subtree\n  // and deletePath the path from the root (inclusive) to replaceWith (exclusive)\n  while (true) {\n    if (replaceWith.right) {\n      deletePath.push(replaceWith);\n      replaceWith = replaceWith.right;\n    } else {\n      break;\n    }\n  }\n  currentNode.key = replaceWith.key;\n  currentNode.data = replaceWith.data;\n  replaceWith.parent.right = replaceWith.left;\n  if (replaceWith.left) {\n    replaceWith.left.parent = replaceWith.parent;\n  }\n  return this.rebalanceAlongPath(deletePath);\n};\n\n// Delete a value\nAVLTree.prototype.delete = function (key, value) {\n  var newTree = this.tree.delete(key, value);\n\n  // If newTree is undefined, that means its structure was not modified\n  if (newTree) {\n    this.tree = newTree;\n  }\n};\n\n/**\n * Other functions we want to use on an AVLTree as if it were the internal _AVLTree\n */\n['getNumberOfKeys', 'search', 'betweenBounds', 'prettyPrint', 'executeOnEveryNode'].forEach(function (fn) {\n  AVLTree.prototype[fn] = function () {\n    return this.tree[fn].apply(this.tree, arguments);\n  };\n});\n\n// Interface\nmodule.exports = AVLTree;","/**\n * Simple binary search tree\n */\nvar customUtils = require('./customUtils');\n\n/**\n * Constructor\n * @param {Object} options Optional\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Key}      options.key Initialize this BST's key with key\n * @param {Value}    options.value Initialize this BST's data with [value]\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\nfunction BinarySearchTree(options) {\n  options = options || {};\n  this.left = null;\n  this.right = null;\n  this.parent = options.parent !== undefined ? options.parent : null;\n  if (options.hasOwnProperty('key')) {\n    this.key = options.key;\n  }\n  this.data = options.hasOwnProperty('value') ? [options.value] : [];\n  this.unique = options.unique || false;\n  this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;\n  this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;\n}\n\n// ================================\n// Methods used to test the tree\n// ================================\n\n/**\n * Get the descendant with max key\n */\nBinarySearchTree.prototype.getMaxKeyDescendant = function () {\n  if (this.right) {\n    return this.right.getMaxKeyDescendant();\n  } else {\n    return this;\n  }\n};\n\n/**\n * Get the maximum key\n */\nBinarySearchTree.prototype.getMaxKey = function () {\n  return this.getMaxKeyDescendant().key;\n};\n\n/**\n * Get the descendant with min key\n */\nBinarySearchTree.prototype.getMinKeyDescendant = function () {\n  if (this.left) {\n    return this.left.getMinKeyDescendant();\n  } else {\n    return this;\n  }\n};\n\n/**\n * Get the minimum key\n */\nBinarySearchTree.prototype.getMinKey = function () {\n  return this.getMinKeyDescendant().key;\n};\n\n/**\n * Check that all nodes (incl. leaves) fullfil condition given by fn\n * test is a function passed every (key, data) and which throws if the condition is not met\n */\nBinarySearchTree.prototype.checkAllNodesFullfillCondition = function (test) {\n  if (!this.hasOwnProperty('key')) {\n    return;\n  }\n  test(this.key, this.data);\n  if (this.left) {\n    this.left.checkAllNodesFullfillCondition(test);\n  }\n  if (this.right) {\n    this.right.checkAllNodesFullfillCondition(test);\n  }\n};\n\n/**\n * Check that the core BST properties on node ordering are verified\n * Throw if they aren't\n */\nBinarySearchTree.prototype.checkNodeOrdering = function () {\n  var self = this;\n  if (!this.hasOwnProperty('key')) {\n    return;\n  }\n  if (this.left) {\n    this.left.checkAllNodesFullfillCondition(function (k) {\n      if (self.compareKeys(k, self.key) >= 0) {\n        throw new Error('Tree with root ' + self.key + ' is not a binary search tree');\n      }\n    });\n    this.left.checkNodeOrdering();\n  }\n  if (this.right) {\n    this.right.checkAllNodesFullfillCondition(function (k) {\n      if (self.compareKeys(k, self.key) <= 0) {\n        throw new Error('Tree with root ' + self.key + ' is not a binary search tree');\n      }\n    });\n    this.right.checkNodeOrdering();\n  }\n};\n\n/**\n * Check that all pointers are coherent in this tree\n */\nBinarySearchTree.prototype.checkInternalPointers = function () {\n  if (this.left) {\n    if (this.left.parent !== this) {\n      throw new Error('Parent pointer broken for key ' + this.key);\n    }\n    this.left.checkInternalPointers();\n  }\n  if (this.right) {\n    if (this.right.parent !== this) {\n      throw new Error('Parent pointer broken for key ' + this.key);\n    }\n    this.right.checkInternalPointers();\n  }\n};\n\n/**\n * Check that a tree is a BST as defined here (node ordering and pointer references)\n */\nBinarySearchTree.prototype.checkIsBST = function () {\n  this.checkNodeOrdering();\n  this.checkInternalPointers();\n  if (this.parent) {\n    throw new Error(\"The root shouldn't have a parent\");\n  }\n};\n\n/**\n * Get number of keys inserted\n */\nBinarySearchTree.prototype.getNumberOfKeys = function () {\n  var res;\n  if (!this.hasOwnProperty('key')) {\n    return 0;\n  }\n  res = 1;\n  if (this.left) {\n    res += this.left.getNumberOfKeys();\n  }\n  if (this.right) {\n    res += this.right.getNumberOfKeys();\n  }\n  return res;\n};\n\n// ============================================\n// Methods used to actually work on the tree\n// ============================================\n\n/**\n * Create a BST similar (i.e. same options except for key and value) to the current one\n * Use the same constructor (i.e. BinarySearchTree, AVLTree etc)\n * @param {Object} options see constructor\n */\nBinarySearchTree.prototype.createSimilar = function (options) {\n  options = options || {};\n  options.unique = this.unique;\n  options.compareKeys = this.compareKeys;\n  options.checkValueEquality = this.checkValueEquality;\n  return new this.constructor(options);\n};\n\n/**\n * Create the left child of this BST and return it\n */\nBinarySearchTree.prototype.createLeftChild = function (options) {\n  var leftChild = this.createSimilar(options);\n  leftChild.parent = this;\n  this.left = leftChild;\n  return leftChild;\n};\n\n/**\n * Create the right child of this BST and return it\n */\nBinarySearchTree.prototype.createRightChild = function (options) {\n  var rightChild = this.createSimilar(options);\n  rightChild.parent = this;\n  this.right = rightChild;\n  return rightChild;\n};\n\n/**\n * Insert a new element\n */\nBinarySearchTree.prototype.insert = function (key, value) {\n  // Empty tree, insert as root\n  if (!this.hasOwnProperty('key')) {\n    this.key = key;\n    this.data.push(value);\n    return;\n  }\n\n  // Same key as root\n  if (this.compareKeys(this.key, key) === 0) {\n    if (this.unique) {\n      var err = new Error(\"Can't insert key \" + key + \", it violates the unique constraint\");\n      err.key = key;\n      err.errorType = 'uniqueViolated';\n      throw err;\n    } else {\n      this.data.push(value);\n    }\n    return;\n  }\n  if (this.compareKeys(key, this.key) < 0) {\n    // Insert in left subtree\n    if (this.left) {\n      this.left.insert(key, value);\n    } else {\n      this.createLeftChild({\n        key: key,\n        value: value\n      });\n    }\n  } else {\n    // Insert in right subtree\n    if (this.right) {\n      this.right.insert(key, value);\n    } else {\n      this.createRightChild({\n        key: key,\n        value: value\n      });\n    }\n  }\n};\n\n/**\n * Search for all data corresponding to a key\n */\nBinarySearchTree.prototype.search = function (key) {\n  if (!this.hasOwnProperty('key')) {\n    return [];\n  }\n  if (this.compareKeys(this.key, key) === 0) {\n    return this.data;\n  }\n  if (this.compareKeys(key, this.key) < 0) {\n    if (this.left) {\n      return this.left.search(key);\n    } else {\n      return [];\n    }\n  } else {\n    if (this.right) {\n      return this.right.search(key);\n    } else {\n      return [];\n    }\n  }\n};\n\n/**\n * Return a function that tells whether a given key matches a lower bound\n */\nBinarySearchTree.prototype.getLowerBoundMatcher = function (query) {\n  var self = this;\n\n  // No lower bound\n  if (!query.hasOwnProperty('$gt') && !query.hasOwnProperty('$gte')) {\n    return function () {\n      return true;\n    };\n  }\n  if (query.hasOwnProperty('$gt') && query.hasOwnProperty('$gte')) {\n    if (self.compareKeys(query.$gte, query.$gt) === 0) {\n      return function (key) {\n        return self.compareKeys(key, query.$gt) > 0;\n      };\n    }\n    if (self.compareKeys(query.$gte, query.$gt) > 0) {\n      return function (key) {\n        return self.compareKeys(key, query.$gte) >= 0;\n      };\n    } else {\n      return function (key) {\n        return self.compareKeys(key, query.$gt) > 0;\n      };\n    }\n  }\n  if (query.hasOwnProperty('$gt')) {\n    return function (key) {\n      return self.compareKeys(key, query.$gt) > 0;\n    };\n  } else {\n    return function (key) {\n      return self.compareKeys(key, query.$gte) >= 0;\n    };\n  }\n};\n\n/**\n * Return a function that tells whether a given key matches an upper bound\n */\nBinarySearchTree.prototype.getUpperBoundMatcher = function (query) {\n  var self = this;\n\n  // No lower bound\n  if (!query.hasOwnProperty('$lt') && !query.hasOwnProperty('$lte')) {\n    return function () {\n      return true;\n    };\n  }\n  if (query.hasOwnProperty('$lt') && query.hasOwnProperty('$lte')) {\n    if (self.compareKeys(query.$lte, query.$lt) === 0) {\n      return function (key) {\n        return self.compareKeys(key, query.$lt) < 0;\n      };\n    }\n    if (self.compareKeys(query.$lte, query.$lt) < 0) {\n      return function (key) {\n        return self.compareKeys(key, query.$lte) <= 0;\n      };\n    } else {\n      return function (key) {\n        return self.compareKeys(key, query.$lt) < 0;\n      };\n    }\n  }\n  if (query.hasOwnProperty('$lt')) {\n    return function (key) {\n      return self.compareKeys(key, query.$lt) < 0;\n    };\n  } else {\n    return function (key) {\n      return self.compareKeys(key, query.$lte) <= 0;\n    };\n  }\n};\n\n// Append all elements in toAppend to array\nfunction append(array, toAppend) {\n  var i;\n  for (i = 0; i < toAppend.length; i += 1) {\n    array.push(toAppend[i]);\n  }\n}\n\n/**\n * Get all data for a key between bounds\n * Return it in key order\n * @param {Object} query Mongo-style query where keys are $lt, $lte, $gt or $gte (other keys are not considered)\n * @param {Functions} lbm/ubm matching functions calculated at the first recursive step\n */\nBinarySearchTree.prototype.betweenBounds = function (query, lbm, ubm) {\n  var res = [];\n  if (!this.hasOwnProperty('key')) {\n    return [];\n  } // Empty tree\n\n  lbm = lbm || this.getLowerBoundMatcher(query);\n  ubm = ubm || this.getUpperBoundMatcher(query);\n  if (lbm(this.key) && this.left) {\n    append(res, this.left.betweenBounds(query, lbm, ubm));\n  }\n  if (lbm(this.key) && ubm(this.key)) {\n    append(res, this.data);\n  }\n  if (ubm(this.key) && this.right) {\n    append(res, this.right.betweenBounds(query, lbm, ubm));\n  }\n  return res;\n};\n\n/**\n * Delete the current node if it is a leaf\n * Return true if it was deleted\n */\nBinarySearchTree.prototype.deleteIfLeaf = function () {\n  if (this.left || this.right) {\n    return false;\n  }\n\n  // The leaf is itself a root\n  if (!this.parent) {\n    delete this.key;\n    this.data = [];\n    return true;\n  }\n  if (this.parent.left === this) {\n    this.parent.left = null;\n  } else {\n    this.parent.right = null;\n  }\n  return true;\n};\n\n/**\n * Delete the current node if it has only one child\n * Return true if it was deleted\n */\nBinarySearchTree.prototype.deleteIfOnlyOneChild = function () {\n  var child;\n  if (this.left && !this.right) {\n    child = this.left;\n  }\n  if (!this.left && this.right) {\n    child = this.right;\n  }\n  if (!child) {\n    return false;\n  }\n\n  // Root\n  if (!this.parent) {\n    this.key = child.key;\n    this.data = child.data;\n    this.left = null;\n    if (child.left) {\n      this.left = child.left;\n      child.left.parent = this;\n    }\n    this.right = null;\n    if (child.right) {\n      this.right = child.right;\n      child.right.parent = this;\n    }\n    return true;\n  }\n  if (this.parent.left === this) {\n    this.parent.left = child;\n    child.parent = this.parent;\n  } else {\n    this.parent.right = child;\n    child.parent = this.parent;\n  }\n  return true;\n};\n\n/**\n * Delete a key or just a value\n * @param {Key} key\n * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n */\nBinarySearchTree.prototype.delete = function (key, value) {\n  var newData = [],\n    replaceWith,\n    self = this;\n  if (!this.hasOwnProperty('key')) {\n    return;\n  }\n  if (this.compareKeys(key, this.key) < 0) {\n    if (this.left) {\n      this.left.delete(key, value);\n    }\n    return;\n  }\n  if (this.compareKeys(key, this.key) > 0) {\n    if (this.right) {\n      this.right.delete(key, value);\n    }\n    return;\n  }\n  if (!this.compareKeys(key, this.key) === 0) {\n    return;\n  }\n\n  // Delete only a value\n  if (this.data.length > 1 && value !== undefined) {\n    this.data.forEach(function (d) {\n      if (!self.checkValueEquality(d, value)) {\n        newData.push(d);\n      }\n    });\n    self.data = newData;\n    return;\n  }\n\n  // Delete the whole node\n  if (this.deleteIfLeaf()) {\n    return;\n  }\n  if (this.deleteIfOnlyOneChild()) {\n    return;\n  }\n\n  // We are in the case where the node to delete has two children\n  if (Math.random() >= 0.5) {\n    // Randomize replacement to avoid unbalancing the tree too much\n    // Use the in-order predecessor\n    replaceWith = this.left.getMaxKeyDescendant();\n    this.key = replaceWith.key;\n    this.data = replaceWith.data;\n    if (this === replaceWith.parent) {\n      // Special case\n      this.left = replaceWith.left;\n      if (replaceWith.left) {\n        replaceWith.left.parent = replaceWith.parent;\n      }\n    } else {\n      replaceWith.parent.right = replaceWith.left;\n      if (replaceWith.left) {\n        replaceWith.left.parent = replaceWith.parent;\n      }\n    }\n  } else {\n    // Use the in-order successor\n    replaceWith = this.right.getMinKeyDescendant();\n    this.key = replaceWith.key;\n    this.data = replaceWith.data;\n    if (this === replaceWith.parent) {\n      // Special case\n      this.right = replaceWith.right;\n      if (replaceWith.right) {\n        replaceWith.right.parent = replaceWith.parent;\n      }\n    } else {\n      replaceWith.parent.left = replaceWith.right;\n      if (replaceWith.right) {\n        replaceWith.right.parent = replaceWith.parent;\n      }\n    }\n  }\n};\n\n/**\n * Execute a function on every node of the tree, in key order\n * @param {Function} fn Signature: node. Most useful will probably be node.key and node.data\n */\nBinarySearchTree.prototype.executeOnEveryNode = function (fn) {\n  if (this.left) {\n    this.left.executeOnEveryNode(fn);\n  }\n  fn(this);\n  if (this.right) {\n    this.right.executeOnEveryNode(fn);\n  }\n};\n\n/**\n * Pretty print a tree\n * @param {Boolean} printData To print the nodes' data along with the key\n */\nBinarySearchTree.prototype.prettyPrint = function (printData, spacing) {\n  spacing = spacing || \"\";\n  console.log(spacing + \"* \" + this.key);\n  if (printData) {\n    console.log(spacing + \"* \" + this.data);\n  }\n  if (!this.left && !this.right) {\n    return;\n  }\n  if (this.left) {\n    this.left.prettyPrint(printData, spacing + \"  \");\n  } else {\n    console.log(spacing + \"  *\");\n  }\n  if (this.right) {\n    this.right.prettyPrint(printData, spacing + \"  \");\n  } else {\n    console.log(spacing + \"  *\");\n  }\n};\n\n// Interface\nmodule.exports = BinarySearchTree;","/**\n * Return an array with the numbers from 0 to n-1, in a random order\n */\nfunction getRandomArray(n) {\n  var res, next;\n  if (n === 0) {\n    return [];\n  }\n  if (n === 1) {\n    return [0];\n  }\n  res = getRandomArray(n - 1);\n  next = Math.floor(Math.random() * n);\n  res.splice(next, 0, n - 1); // Add n-1 at a random position in the array\n\n  return res;\n}\n;\nmodule.exports.getRandomArray = getRandomArray;\n\n/*\n * Default compareKeys function will work for numbers, strings and dates\n */\nfunction defaultCompareKeysFunction(a, b) {\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  if (a === b) {\n    return 0;\n  }\n  var err = new Error(\"Couldn't compare elements\");\n  err.a = a;\n  err.b = b;\n  throw err;\n}\nmodule.exports.defaultCompareKeysFunction = defaultCompareKeysFunction;\n\n/**\n * Check whether two values are equal (used in non-unique deletion)\n */\nfunction defaultCheckValueEquality(a, b) {\n  return a === b;\n}\nmodule.exports.defaultCheckValueEquality = defaultCheckValueEquality;","var path = require('path');\nvar fs = require('fs');\nvar _0777 = parseInt('0777', 8);\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\nfunction mkdirP(p, opts, f, made) {\n  if (typeof opts === 'function') {\n    f = opts;\n    opts = {};\n  } else if (!opts || typeof opts !== 'object') {\n    opts = {\n      mode: opts\n    };\n  }\n  var mode = opts.mode;\n  var xfs = opts.fs || fs;\n  if (mode === undefined) {\n    mode = _0777;\n  }\n  if (!made) made = null;\n  var cb = f || /* istanbul ignore next */function () {};\n  p = path.resolve(p);\n  xfs.mkdir(p, mode, function (er) {\n    if (!er) {\n      made = made || p;\n      return cb(null, made);\n    }\n    switch (er.code) {\n      case 'ENOENT':\n        /* istanbul ignore if */\n        if (path.dirname(p) === p) return cb(er);\n        mkdirP(path.dirname(p), opts, function (er, made) {\n          /* istanbul ignore if */\n          if (er) cb(er, made);else mkdirP(p, opts, cb, made);\n        });\n        break;\n\n      // In the case of any other error, just see if there's a dir\n      // there already.  If so, then hooray!  If not, then something\n      // is borked.\n      default:\n        xfs.stat(p, function (er2, stat) {\n          // if the stat fails, then that's super weird.\n          // let the original error be the failure reason.\n          if (er2 || !stat.isDirectory()) cb(er, made);else cb(null, made);\n        });\n        break;\n    }\n  });\n}\nmkdirP.sync = function sync(p, opts, made) {\n  if (!opts || typeof opts !== 'object') {\n    opts = {\n      mode: opts\n    };\n  }\n  var mode = opts.mode;\n  var xfs = opts.fs || fs;\n  if (mode === undefined) {\n    mode = _0777;\n  }\n  if (!made) made = null;\n  p = path.resolve(p);\n  try {\n    xfs.mkdirSync(p, mode);\n    made = made || p;\n  } catch (err0) {\n    switch (err0.code) {\n      case 'ENOENT':\n        made = sync(path.dirname(p), opts, made);\n        sync(p, opts, made);\n        break;\n\n      // In the case of any other error, just see if there's a dir\n      // there already.  If so, then hooray!  If not, then something\n      // is borked.\n      default:\n        var stat;\n        try {\n          stat = xfs.statSync(p);\n        } catch (err1) /* istanbul ignore next */{\n          throw err0;\n        }\n        /* istanbul ignore if */\n        if (!stat.isDirectory()) throw err0;\n        break;\n    }\n  }\n  return made;\n};","var Datastore = require('./lib/datastore');\nmodule.exports = Datastore;","/**\n * Manage access to data, be it to find, update or remove it\n */\nvar model = require('./model'),\n  _ = require('underscore');\n\n/**\n * Create a new cursor for this collection\n * @param {Datastore} db - The datastore this cursor is bound to\n * @param {Query} query - The query this cursor will operate on\n * @param {Function} execFn - Handler to be executed after cursor has found the results and before the callback passed to find/findOne/update/remove\n */\nfunction Cursor(db, query, execFn) {\n  this.db = db;\n  this.query = query || {};\n  if (execFn) {\n    this.execFn = execFn;\n  }\n}\n\n/**\n * Set a limit to the number of results\n */\nCursor.prototype.limit = function (limit) {\n  this._limit = limit;\n  return this;\n};\n\n/**\n * Skip a the number of results\n */\nCursor.prototype.skip = function (skip) {\n  this._skip = skip;\n  return this;\n};\n\n/**\n * Sort results of the query\n * @param {SortQuery} sortQuery - SortQuery is { field: order }, field can use the dot-notation, order is 1 for ascending and -1 for descending\n */\nCursor.prototype.sort = function (sortQuery) {\n  this._sort = sortQuery;\n  return this;\n};\n\n/**\n * Add the use of a projection\n * @param {Object} projection - MongoDB-style projection. {} means take all fields. Then it's { key1: 1, key2: 1 } to take only key1 and key2\n *                              { key1: 0, key2: 0 } to omit only key1 and key2. Except _id, you can't mix takes and omits\n */\nCursor.prototype.projection = function (projection) {\n  this._projection = projection;\n  return this;\n};\n\n/**\n * Apply the projection\n */\nCursor.prototype.project = function (candidates) {\n  var res = [],\n    self = this,\n    keepId,\n    action,\n    keys;\n  if (this._projection === undefined || Object.keys(this._projection).length === 0) {\n    return candidates;\n  }\n  keepId = this._projection._id === 0 ? false : true;\n  this._projection = _.omit(this._projection, '_id');\n\n  // Check for consistency\n  keys = Object.keys(this._projection);\n  keys.forEach(function (k) {\n    if (action !== undefined && self._projection[k] !== action) {\n      throw new Error(\"Can't both keep and omit fields except for _id\");\n    }\n    action = self._projection[k];\n  });\n\n  // Do the actual projection\n  candidates.forEach(function (candidate) {\n    var toPush;\n    if (action === 1) {\n      // pick-type projection\n      toPush = {\n        $set: {}\n      };\n      keys.forEach(function (k) {\n        toPush.$set[k] = model.getDotValue(candidate, k);\n        if (toPush.$set[k] === undefined) {\n          delete toPush.$set[k];\n        }\n      });\n      toPush = model.modify({}, toPush);\n    } else {\n      // omit-type projection\n      toPush = {\n        $unset: {}\n      };\n      keys.forEach(function (k) {\n        toPush.$unset[k] = true;\n      });\n      toPush = model.modify(candidate, toPush);\n    }\n    if (keepId) {\n      toPush._id = candidate._id;\n    } else {\n      delete toPush._id;\n    }\n    res.push(toPush);\n  });\n  return res;\n};\n\n/**\n * Get all matching elements\n * Will return pointers to matched elements (shallow copies), returning full copies is the role of find or findOne\n * This is an internal function, use exec which uses the executor\n *\n * @param {Function} callback - Signature: err, results\n */\nCursor.prototype._exec = function (_callback) {\n  var res = [],\n    added = 0,\n    skipped = 0,\n    self = this,\n    error = null,\n    i,\n    keys,\n    key;\n  function callback(error, res) {\n    if (self.execFn) {\n      return self.execFn(error, res, _callback);\n    } else {\n      return _callback(error, res);\n    }\n  }\n  this.db.getCandidates(this.query, function (err, candidates) {\n    if (err) {\n      return callback(err);\n    }\n    try {\n      for (i = 0; i < candidates.length; i += 1) {\n        if (model.match(candidates[i], self.query)) {\n          // If a sort is defined, wait for the results to be sorted before applying limit and skip\n          if (!self._sort) {\n            if (self._skip && self._skip > skipped) {\n              skipped += 1;\n            } else {\n              res.push(candidates[i]);\n              added += 1;\n              if (self._limit && self._limit <= added) {\n                break;\n              }\n            }\n          } else {\n            res.push(candidates[i]);\n          }\n        }\n      }\n    } catch (err) {\n      return callback(err);\n    }\n\n    // Apply all sorts\n    if (self._sort) {\n      keys = Object.keys(self._sort);\n\n      // Sorting\n      var criteria = [];\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n        criteria.push({\n          key: key,\n          direction: self._sort[key]\n        });\n      }\n      res.sort(function (a, b) {\n        var criterion, compare, i;\n        for (i = 0; i < criteria.length; i++) {\n          criterion = criteria[i];\n          compare = criterion.direction * model.compareThings(model.getDotValue(a, criterion.key), model.getDotValue(b, criterion.key), self.db.compareStrings);\n          if (compare !== 0) {\n            return compare;\n          }\n        }\n        return 0;\n      });\n\n      // Applying limit and skip\n      var limit = self._limit || res.length,\n        skip = self._skip || 0;\n      res = res.slice(skip, skip + limit);\n    }\n\n    // Apply projection\n    try {\n      res = self.project(res);\n    } catch (e) {\n      error = e;\n      res = undefined;\n    }\n    return callback(error, res);\n  });\n};\nCursor.prototype.exec = function () {\n  this.db.executor.push({\n    this: this,\n    fn: this._exec,\n    arguments: arguments\n  });\n};\n\n// Interface\nmodule.exports = Cursor;","var crypto = require('crypto');\n\n/**\n * Return a random alphanumerical string of length len\n * There is a very small probability (less than 1/1,000,000) for the length to be less than len\n * (il the base64 conversion yields too many pluses and slashes) but\n * that's not an issue here\n * The probability of a collision is extremely small (need 3*10^12 documents to have one chance in a million of a collision)\n * See http://en.wikipedia.org/wiki/Birthday_problem\n */\nfunction uid(len) {\n  return crypto.randomBytes(Math.ceil(Math.max(8, len * 2))).toString('base64').replace(/[+\\/]/g, '').slice(0, len);\n}\n\n// Interface\nmodule.exports.uid = uid;","var customUtils = require('./customUtils'),\n  model = require('./model'),\n  async = require('async'),\n  Executor = require('./executor'),\n  Index = require('./indexes'),\n  util = require('util'),\n  _ = require('underscore'),\n  Persistence = require('./persistence'),\n  Cursor = require('./cursor');\n\n/**\n * Create a new collection\n * @param {String} options.filename Optional, datastore will be in-memory only if not provided\n * @param {Boolean} options.timestampData Optional, defaults to false. If set to true, createdAt and updatedAt will be created and populated automatically (if not specified by user)\n * @param {Boolean} options.inMemoryOnly Optional, defaults to false\n * @param {String} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where\n *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)\n * @param {Boolean} options.autoload Optional, defaults to false\n * @param {Function} options.onload Optional, if autoload is used this will be called after the load database with the error object as parameter. If you don't pass it the error will be thrown\n * @param {Function} options.afterSerialization/options.beforeDeserialization Optional, serialization hooks\n * @param {Number} options.corruptAlertThreshold Optional, threshold after which an alert is thrown if too much data is corrupt\n * @param {Function} options.compareStrings Optional, string comparison function that overrides default for sorting\n *\n * Event Emitter - Events\n * * compaction.done - Fired whenever a compaction operation was finished\n */\nfunction Datastore(options) {\n  var filename;\n\n  // Retrocompatibility with v0.6 and before\n  if (typeof options === 'string') {\n    filename = options;\n    this.inMemoryOnly = false; // Default\n  } else {\n    options = options || {};\n    filename = options.filename;\n    this.inMemoryOnly = options.inMemoryOnly || false;\n    this.autoload = options.autoload || false;\n    this.timestampData = options.timestampData || false;\n  }\n\n  // Determine whether in memory or persistent\n  if (!filename || typeof filename !== 'string' || filename.length === 0) {\n    this.filename = null;\n    this.inMemoryOnly = true;\n  } else {\n    this.filename = filename;\n  }\n\n  // String comparison function\n  this.compareStrings = options.compareStrings;\n\n  // Persistence handling\n  this.persistence = new Persistence({\n    db: this,\n    nodeWebkitAppName: options.nodeWebkitAppName,\n    afterSerialization: options.afterSerialization,\n    beforeDeserialization: options.beforeDeserialization,\n    corruptAlertThreshold: options.corruptAlertThreshold\n  });\n\n  // This new executor is ready if we don't use persistence\n  // If we do, it will only be ready once loadDatabase is called\n  this.executor = new Executor();\n  if (this.inMemoryOnly) {\n    this.executor.ready = true;\n  }\n\n  // Indexed by field name, dot notation can be used\n  // _id is always indexed and since _ids are generated randomly the underlying\n  // binary is always well-balanced\n  this.indexes = {};\n  this.indexes._id = new Index({\n    fieldName: '_id',\n    unique: true\n  });\n  this.ttlIndexes = {};\n\n  // Queue a load of the database right away and call the onload handler\n  // By default (no onload handler), if there is an error there, no operation will be possible so warn the user by throwing an exception\n  if (this.autoload) {\n    this.loadDatabase(options.onload || function (err) {\n      if (err) {\n        throw err;\n      }\n    });\n  }\n}\nutil.inherits(Datastore, require('events').EventEmitter);\n\n/**\n * Load the database from the datafile, and trigger the execution of buffered commands if any\n */\nDatastore.prototype.loadDatabase = function () {\n  this.executor.push({\n    this: this.persistence,\n    fn: this.persistence.loadDatabase,\n    arguments: arguments\n  }, true);\n};\n\n/**\n * Get an array of all the data in the database\n */\nDatastore.prototype.getAllData = function () {\n  return this.indexes._id.getAll();\n};\n\n/**\n * Reset all currently defined indexes\n */\nDatastore.prototype.resetIndexes = function (newData) {\n  var self = this;\n  Object.keys(this.indexes).forEach(function (i) {\n    self.indexes[i].reset(newData);\n  });\n};\n\n/**\n * Ensure an index is kept for this field. Same parameters as lib/indexes\n * For now this function is synchronous, we need to test how much time it takes\n * We use an async API for consistency with the rest of the code\n * @param {String} options.fieldName\n * @param {Boolean} options.unique\n * @param {Boolean} options.sparse\n * @param {Number} options.expireAfterSeconds - Optional, if set this index becomes a TTL index (only works on Date fields, not arrays of Date)\n * @param {Function} cb Optional callback, signature: err\n */\nDatastore.prototype.ensureIndex = function (options, cb) {\n  var err,\n    callback = cb || function () {};\n  options = options || {};\n  if (!options.fieldName) {\n    err = new Error(\"Cannot create an index without a fieldName\");\n    err.missingFieldName = true;\n    return callback(err);\n  }\n  if (this.indexes[options.fieldName]) {\n    return callback(null);\n  }\n  this.indexes[options.fieldName] = new Index(options);\n  if (options.expireAfterSeconds !== undefined) {\n    this.ttlIndexes[options.fieldName] = options.expireAfterSeconds;\n  } // With this implementation index creation is not necessary to ensure TTL but we stick with MongoDB's API here\n\n  try {\n    this.indexes[options.fieldName].insert(this.getAllData());\n  } catch (e) {\n    delete this.indexes[options.fieldName];\n    return callback(e);\n  }\n\n  // We may want to force all options to be persisted including defaults, not just the ones passed the index creation function\n  this.persistence.persistNewState([{\n    $$indexCreated: options\n  }], function (err) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null);\n  });\n};\n\n/**\n * Remove an index\n * @param {String} fieldName\n * @param {Function} cb Optional callback, signature: err\n */\nDatastore.prototype.removeIndex = function (fieldName, cb) {\n  var callback = cb || function () {};\n  delete this.indexes[fieldName];\n  this.persistence.persistNewState([{\n    $$indexRemoved: fieldName\n  }], function (err) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null);\n  });\n};\n\n/**\n * Add one or several document(s) to all indexes\n */\nDatastore.prototype.addToIndexes = function (doc) {\n  var i,\n    failingIndex,\n    error,\n    keys = Object.keys(this.indexes);\n  for (i = 0; i < keys.length; i += 1) {\n    try {\n      this.indexes[keys[i]].insert(doc);\n    } catch (e) {\n      failingIndex = i;\n      error = e;\n      break;\n    }\n  }\n\n  // If an error happened, we need to rollback the insert on all other indexes\n  if (error) {\n    for (i = 0; i < failingIndex; i += 1) {\n      this.indexes[keys[i]].remove(doc);\n    }\n    throw error;\n  }\n};\n\n/**\n * Remove one or several document(s) from all indexes\n */\nDatastore.prototype.removeFromIndexes = function (doc) {\n  var self = this;\n  Object.keys(this.indexes).forEach(function (i) {\n    self.indexes[i].remove(doc);\n  });\n};\n\n/**\n * Update one or several documents in all indexes\n * To update multiple documents, oldDoc must be an array of { oldDoc, newDoc } pairs\n * If one update violates a constraint, all changes are rolled back\n */\nDatastore.prototype.updateIndexes = function (oldDoc, newDoc) {\n  var i,\n    failingIndex,\n    error,\n    keys = Object.keys(this.indexes);\n  for (i = 0; i < keys.length; i += 1) {\n    try {\n      this.indexes[keys[i]].update(oldDoc, newDoc);\n    } catch (e) {\n      failingIndex = i;\n      error = e;\n      break;\n    }\n  }\n\n  // If an error happened, we need to rollback the update on all other indexes\n  if (error) {\n    for (i = 0; i < failingIndex; i += 1) {\n      this.indexes[keys[i]].revertUpdate(oldDoc, newDoc);\n    }\n    throw error;\n  }\n};\n\n/**\n * Return the list of candidates for a given query\n * Crude implementation for now, we return the candidates given by the first usable index if any\n * We try the following query types, in this order: basic match, $in match, comparison match\n * One way to make it better would be to enable the use of multiple indexes if the first usable index\n * returns too much data. I may do it in the future.\n *\n * Returned candidates will be scanned to find and remove all expired documents\n *\n * @param {Query} query\n * @param {Boolean} dontExpireStaleDocs Optional, defaults to false, if true don't remove stale docs. Useful for the remove function which shouldn't be impacted by expirations\n * @param {Function} callback Signature err, docs\n */\nDatastore.prototype.getCandidates = function (query, dontExpireStaleDocs, callback) {\n  var indexNames = Object.keys(this.indexes),\n    self = this,\n    usableQueryKeys;\n  if (typeof dontExpireStaleDocs === 'function') {\n    callback = dontExpireStaleDocs;\n    dontExpireStaleDocs = false;\n  }\n  async.waterfall([\n  // STEP 1: get candidates list by checking indexes from most to least frequent usecase\n  function (cb) {\n    // For a basic match\n    usableQueryKeys = [];\n    Object.keys(query).forEach(function (k) {\n      if (typeof query[k] === 'string' || typeof query[k] === 'number' || typeof query[k] === 'boolean' || util.isDate(query[k]) || query[k] === null) {\n        usableQueryKeys.push(k);\n      }\n    });\n    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\n    if (usableQueryKeys.length > 0) {\n      return cb(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]]));\n    }\n\n    // For a $in match\n    usableQueryKeys = [];\n    Object.keys(query).forEach(function (k) {\n      if (query[k] && query[k].hasOwnProperty('$in')) {\n        usableQueryKeys.push(k);\n      }\n    });\n    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\n    if (usableQueryKeys.length > 0) {\n      return cb(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]].$in));\n    }\n\n    // For a comparison match\n    usableQueryKeys = [];\n    Object.keys(query).forEach(function (k) {\n      if (query[k] && (query[k].hasOwnProperty('$lt') || query[k].hasOwnProperty('$lte') || query[k].hasOwnProperty('$gt') || query[k].hasOwnProperty('$gte'))) {\n        usableQueryKeys.push(k);\n      }\n    });\n    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\n    if (usableQueryKeys.length > 0) {\n      return cb(null, self.indexes[usableQueryKeys[0]].getBetweenBounds(query[usableQueryKeys[0]]));\n    }\n\n    // By default, return all the DB data\n    return cb(null, self.getAllData());\n  }\n  // STEP 2: remove all expired documents\n  , function (docs) {\n    if (dontExpireStaleDocs) {\n      return callback(null, docs);\n    }\n    var expiredDocsIds = [],\n      validDocs = [],\n      ttlIndexesFieldNames = Object.keys(self.ttlIndexes);\n    docs.forEach(function (doc) {\n      var valid = true;\n      ttlIndexesFieldNames.forEach(function (i) {\n        if (doc[i] !== undefined && util.isDate(doc[i]) && Date.now() > doc[i].getTime() + self.ttlIndexes[i] * 1000) {\n          valid = false;\n        }\n      });\n      if (valid) {\n        validDocs.push(doc);\n      } else {\n        expiredDocsIds.push(doc._id);\n      }\n    });\n    async.eachSeries(expiredDocsIds, function (_id, cb) {\n      self._remove({\n        _id: _id\n      }, {}, function (err) {\n        if (err) {\n          return callback(err);\n        }\n        return cb();\n      });\n    }, function (err) {\n      return callback(null, validDocs);\n    });\n  }]);\n};\n\n/**\n * Insert a new document\n * @param {Function} cb Optional callback, signature: err, insertedDoc\n *\n * @api private Use Datastore.insert which has the same signature\n */\nDatastore.prototype._insert = function (newDoc, cb) {\n  var callback = cb || function () {},\n    preparedDoc;\n  try {\n    preparedDoc = this.prepareDocumentForInsertion(newDoc);\n    this._insertInCache(preparedDoc);\n  } catch (e) {\n    return callback(e);\n  }\n  this.persistence.persistNewState(util.isArray(preparedDoc) ? preparedDoc : [preparedDoc], function (err) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, model.deepCopy(preparedDoc));\n  });\n};\n\n/**\n * Create a new _id that's not already in use\n */\nDatastore.prototype.createNewId = function () {\n  var tentativeId = customUtils.uid(16);\n  // Try as many times as needed to get an unused _id. As explained in customUtils, the probability of this ever happening is extremely small, so this is O(1)\n  if (this.indexes._id.getMatching(tentativeId).length > 0) {\n    tentativeId = this.createNewId();\n  }\n  return tentativeId;\n};\n\n/**\n * Prepare a document (or array of documents) to be inserted in a database\n * Meaning adds _id and timestamps if necessary on a copy of newDoc to avoid any side effect on user input\n * @api private\n */\nDatastore.prototype.prepareDocumentForInsertion = function (newDoc) {\n  var preparedDoc,\n    self = this;\n  if (util.isArray(newDoc)) {\n    preparedDoc = [];\n    newDoc.forEach(function (doc) {\n      preparedDoc.push(self.prepareDocumentForInsertion(doc));\n    });\n  } else {\n    preparedDoc = model.deepCopy(newDoc);\n    if (preparedDoc._id === undefined) {\n      preparedDoc._id = this.createNewId();\n    }\n    var now = new Date();\n    if (this.timestampData && preparedDoc.createdAt === undefined) {\n      preparedDoc.createdAt = now;\n    }\n    if (this.timestampData && preparedDoc.updatedAt === undefined) {\n      preparedDoc.updatedAt = now;\n    }\n    model.checkObject(preparedDoc);\n  }\n  return preparedDoc;\n};\n\n/**\n * If newDoc is an array of documents, this will insert all documents in the cache\n * @api private\n */\nDatastore.prototype._insertInCache = function (preparedDoc) {\n  if (util.isArray(preparedDoc)) {\n    this._insertMultipleDocsInCache(preparedDoc);\n  } else {\n    this.addToIndexes(preparedDoc);\n  }\n};\n\n/**\n * If one insertion fails (e.g. because of a unique constraint), roll back all previous\n * inserts and throws the error\n * @api private\n */\nDatastore.prototype._insertMultipleDocsInCache = function (preparedDocs) {\n  var i, failingI, error;\n  for (i = 0; i < preparedDocs.length; i += 1) {\n    try {\n      this.addToIndexes(preparedDocs[i]);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  }\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.removeFromIndexes(preparedDocs[i]);\n    }\n    throw error;\n  }\n};\nDatastore.prototype.insert = function () {\n  this.executor.push({\n    this: this,\n    fn: this._insert,\n    arguments: arguments\n  });\n};\n\n/**\n * Count all documents matching the query\n * @param {Object} query MongoDB-style query\n */\nDatastore.prototype.count = function (query, callback) {\n  var cursor = new Cursor(this, query, function (err, docs, callback) {\n    if (err) {\n      return callback(err);\n    }\n    return callback(null, docs.length);\n  });\n  if (typeof callback === 'function') {\n    cursor.exec(callback);\n  } else {\n    return cursor;\n  }\n};\n\n/**\n * Find all documents matching the query\n * If no callback is passed, we return the cursor so that user can limit, skip and finally exec\n * @param {Object} query MongoDB-style query\n * @param {Object} projection MongoDB-style projection\n */\nDatastore.prototype.find = function (query, projection, callback) {\n  switch (arguments.length) {\n    case 1:\n      projection = {};\n      // callback is undefined, will return a cursor\n      break;\n    case 2:\n      if (typeof projection === 'function') {\n        callback = projection;\n        projection = {};\n      } // If not assume projection is an object and callback undefined\n      break;\n  }\n  var cursor = new Cursor(this, query, function (err, docs, callback) {\n    var res = [],\n      i;\n    if (err) {\n      return callback(err);\n    }\n    for (i = 0; i < docs.length; i += 1) {\n      res.push(model.deepCopy(docs[i]));\n    }\n    return callback(null, res);\n  });\n  cursor.projection(projection);\n  if (typeof callback === 'function') {\n    cursor.exec(callback);\n  } else {\n    return cursor;\n  }\n};\n\n/**\n * Find one document matching the query\n * @param {Object} query MongoDB-style query\n * @param {Object} projection MongoDB-style projection\n */\nDatastore.prototype.findOne = function (query, projection, callback) {\n  switch (arguments.length) {\n    case 1:\n      projection = {};\n      // callback is undefined, will return a cursor\n      break;\n    case 2:\n      if (typeof projection === 'function') {\n        callback = projection;\n        projection = {};\n      } // If not assume projection is an object and callback undefined\n      break;\n  }\n  var cursor = new Cursor(this, query, function (err, docs, callback) {\n    if (err) {\n      return callback(err);\n    }\n    if (docs.length === 1) {\n      return callback(null, model.deepCopy(docs[0]));\n    } else {\n      return callback(null, null);\n    }\n  });\n  cursor.projection(projection).limit(1);\n  if (typeof callback === 'function') {\n    cursor.exec(callback);\n  } else {\n    return cursor;\n  }\n};\n\n/**\n * Update all docs matching query\n * @param {Object} query\n * @param {Object} updateQuery\n * @param {Object} options Optional options\n *                 options.multi If true, can update multiple documents (defaults to false)\n *                 options.upsert If true, document is inserted if the query doesn't match anything\n *                 options.returnUpdatedDocs Defaults to false, if true return as third argument the array of updated matched documents (even if no change actually took place)\n * @param {Function} cb Optional callback, signature: (err, numAffected, affectedDocuments, upsert)\n *                      If update was an upsert, upsert flag is set to true\n *                      affectedDocuments can be one of the following:\n *                        * For an upsert, the upserted document\n *                        * For an update with returnUpdatedDocs option false, null\n *                        * For an update with returnUpdatedDocs true and multi false, the updated document\n *                        * For an update with returnUpdatedDocs true and multi true, the array of updated documents\n *\n * WARNING: The API was changed between v1.7.4 and v1.8, for consistency and readability reasons. Prior and including to v1.7.4,\n *          the callback signature was (err, numAffected, updated) where updated was the updated document in case of an upsert\n *          or the array of updated documents for an update if the returnUpdatedDocs option was true. That meant that the type of\n *          affectedDocuments in a non multi update depended on whether there was an upsert or not, leaving only two ways for the\n *          user to check whether an upsert had occured: checking the type of affectedDocuments or running another find query on\n *          the whole dataset to check its size. Both options being ugly, the breaking change was necessary.\n *\n * @api private Use Datastore.update which has the same signature\n */\nDatastore.prototype._update = function (query, updateQuery, options, cb) {\n  var callback,\n    self = this,\n    numReplaced = 0,\n    multi,\n    upsert,\n    i;\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n  callback = cb || function () {};\n  multi = options.multi !== undefined ? options.multi : false;\n  upsert = options.upsert !== undefined ? options.upsert : false;\n  async.waterfall([function (cb) {\n    // If upsert option is set, check whether we need to insert the doc\n    if (!upsert) {\n      return cb();\n    }\n\n    // Need to use an internal function not tied to the executor to avoid deadlock\n    var cursor = new Cursor(self, query);\n    cursor.limit(1)._exec(function (err, docs) {\n      if (err) {\n        return callback(err);\n      }\n      if (docs.length === 1) {\n        return cb();\n      } else {\n        var toBeInserted;\n        try {\n          model.checkObject(updateQuery);\n          // updateQuery is a simple object with no modifier, use it as the document to insert\n          toBeInserted = updateQuery;\n        } catch (e) {\n          // updateQuery contains modifiers, use the find query as the base,\n          // strip it from all operators and update it according to updateQuery\n          try {\n            toBeInserted = model.modify(model.deepCopy(query, true), updateQuery);\n          } catch (err) {\n            return callback(err);\n          }\n        }\n        return self._insert(toBeInserted, function (err, newDoc) {\n          if (err) {\n            return callback(err);\n          }\n          return callback(null, 1, newDoc, true);\n        });\n      }\n    });\n  }, function () {\n    // Perform the update\n    var modifiedDoc,\n      modifications = [],\n      createdAt;\n    self.getCandidates(query, function (err, candidates) {\n      if (err) {\n        return callback(err);\n      }\n\n      // Preparing update (if an error is thrown here neither the datafile nor\n      // the in-memory indexes are affected)\n      try {\n        for (i = 0; i < candidates.length; i += 1) {\n          if (model.match(candidates[i], query) && (multi || numReplaced === 0)) {\n            numReplaced += 1;\n            if (self.timestampData) {\n              createdAt = candidates[i].createdAt;\n            }\n            modifiedDoc = model.modify(candidates[i], updateQuery);\n            if (self.timestampData) {\n              modifiedDoc.createdAt = createdAt;\n              modifiedDoc.updatedAt = new Date();\n            }\n            modifications.push({\n              oldDoc: candidates[i],\n              newDoc: modifiedDoc\n            });\n          }\n        }\n      } catch (err) {\n        return callback(err);\n      }\n\n      // Change the docs in memory\n      try {\n        self.updateIndexes(modifications);\n      } catch (err) {\n        return callback(err);\n      }\n\n      // Update the datafile\n      var updatedDocs = _.pluck(modifications, 'newDoc');\n      self.persistence.persistNewState(updatedDocs, function (err) {\n        if (err) {\n          return callback(err);\n        }\n        if (!options.returnUpdatedDocs) {\n          return callback(null, numReplaced);\n        } else {\n          var updatedDocsDC = [];\n          updatedDocs.forEach(function (doc) {\n            updatedDocsDC.push(model.deepCopy(doc));\n          });\n          if (!multi) {\n            updatedDocsDC = updatedDocsDC[0];\n          }\n          return callback(null, numReplaced, updatedDocsDC);\n        }\n      });\n    });\n  }]);\n};\nDatastore.prototype.update = function () {\n  this.executor.push({\n    this: this,\n    fn: this._update,\n    arguments: arguments\n  });\n};\n\n/**\n * Remove all docs matching the query\n * For now very naive implementation (similar to update)\n * @param {Object} query\n * @param {Object} options Optional options\n *                 options.multi If true, can update multiple documents (defaults to false)\n * @param {Function} cb Optional callback, signature: err, numRemoved\n *\n * @api private Use Datastore.remove which has the same signature\n */\nDatastore.prototype._remove = function (query, options, cb) {\n  var callback,\n    self = this,\n    numRemoved = 0,\n    removedDocs = [],\n    multi;\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n  callback = cb || function () {};\n  multi = options.multi !== undefined ? options.multi : false;\n  this.getCandidates(query, true, function (err, candidates) {\n    if (err) {\n      return callback(err);\n    }\n    try {\n      candidates.forEach(function (d) {\n        if (model.match(d, query) && (multi || numRemoved === 0)) {\n          numRemoved += 1;\n          removedDocs.push({\n            $$deleted: true,\n            _id: d._id\n          });\n          self.removeFromIndexes(d);\n        }\n      });\n    } catch (err) {\n      return callback(err);\n    }\n    self.persistence.persistNewState(removedDocs, function (err) {\n      if (err) {\n        return callback(err);\n      }\n      return callback(null, numRemoved);\n    });\n  });\n};\nDatastore.prototype.remove = function () {\n  this.executor.push({\n    this: this,\n    fn: this._remove,\n    arguments: arguments\n  });\n};\nmodule.exports = Datastore;","/**\n * Responsible for sequentially executing actions on the database\n */\n\nvar async = require('async');\nfunction Executor() {\n  this.buffer = [];\n  this.ready = false;\n\n  // This queue will execute all commands, one-by-one in order\n  this.queue = async.queue(function (task, cb) {\n    var newArguments = [];\n\n    // task.arguments is an array-like object on which adding a new field doesn't work, so we transform it into a real array\n    for (var i = 0; i < task.arguments.length; i += 1) {\n      newArguments.push(task.arguments[i]);\n    }\n    var lastArg = task.arguments[task.arguments.length - 1];\n\n    // Always tell the queue task is complete. Execute callback if any was given.\n    if (typeof lastArg === 'function') {\n      // Callback was supplied\n      newArguments[newArguments.length - 1] = function () {\n        if (typeof setImmediate === 'function') {\n          setImmediate(cb);\n        } else {\n          process.nextTick(cb);\n        }\n        lastArg.apply(null, arguments);\n      };\n    } else if (!lastArg && task.arguments.length !== 0) {\n      // false/undefined/null supplied as callbback\n      newArguments[newArguments.length - 1] = function () {\n        cb();\n      };\n    } else {\n      // Nothing supplied as callback\n      newArguments.push(function () {\n        cb();\n      });\n    }\n    task.fn.apply(task.this, newArguments);\n  }, 1);\n}\n\n/**\n * If executor is ready, queue task (and process it immediately if executor was idle)\n * If not, buffer task for later processing\n * @param {Object} task\n *                 task.this - Object to use as this\n *                 task.fn - Function to execute\n *                 task.arguments - Array of arguments, IMPORTANT: only the last argument may be a function (the callback)\n *                                                                 and the last argument cannot be false/undefined/null\n * @param {Boolean} forceQueuing Optional (defaults to false) force executor to queue task even if it is not ready\n */\nExecutor.prototype.push = function (task, forceQueuing) {\n  if (this.ready || forceQueuing) {\n    this.queue.push(task);\n  } else {\n    this.buffer.push(task);\n  }\n};\n\n/**\n * Queue all tasks in buffer (in the same order they came in)\n * Automatically sets executor as ready\n */\nExecutor.prototype.processBuffer = function () {\n  var i;\n  this.ready = true;\n  for (i = 0; i < this.buffer.length; i += 1) {\n    this.queue.push(this.buffer[i]);\n  }\n  this.buffer = [];\n};\n\n// Interface\nmodule.exports = Executor;","var BinarySearchTree = require('binary-search-tree').AVLTree,\n  model = require('./model'),\n  _ = require('underscore'),\n  util = require('util');\n\n/**\n * Two indexed pointers are equal iif they point to the same place\n */\nfunction checkValueEquality(a, b) {\n  return a === b;\n}\n\n/**\n * Type-aware projection\n */\nfunction projectForUnique(elt) {\n  if (elt === null) {\n    return '$null';\n  }\n  if (typeof elt === 'string') {\n    return '$string' + elt;\n  }\n  if (typeof elt === 'boolean') {\n    return '$boolean' + elt;\n  }\n  if (typeof elt === 'number') {\n    return '$number' + elt;\n  }\n  if (util.isArray(elt)) {\n    return '$date' + elt.getTime();\n  }\n  return elt; // Arrays and objects, will check for pointer equality\n}\n\n/**\n * Create a new index\n * All methods on an index guarantee that either the whole operation was successful and the index changed\n * or the operation was unsuccessful and an error is thrown while the index is unchanged\n * @param {String} options.fieldName On which field should the index apply (can use dot notation to index on sub fields)\n * @param {Boolean} options.unique Optional, enforce a unique constraint (default: false)\n * @param {Boolean} options.sparse Optional, allow a sparse index (we can have documents for which fieldName is undefined) (default: false)\n */\nfunction Index(options) {\n  this.fieldName = options.fieldName;\n  this.unique = options.unique || false;\n  this.sparse = options.sparse || false;\n  this.treeOptions = {\n    unique: this.unique,\n    compareKeys: model.compareThings,\n    checkValueEquality: checkValueEquality\n  };\n  this.reset(); // No data in the beginning\n}\n\n/**\n * Reset an index\n * @param {Document or Array of documents} newData Optional, data to initialize the index with\n *                                                 If an error is thrown during insertion, the index is not modified\n */\nIndex.prototype.reset = function (newData) {\n  this.tree = new BinarySearchTree(this.treeOptions);\n  if (newData) {\n    this.insert(newData);\n  }\n};\n\n/**\n * Insert a new document in the index\n * If an array is passed, we insert all its elements (if one insertion fails the index is not modified)\n * O(log(n))\n */\nIndex.prototype.insert = function (doc) {\n  var key,\n    self = this,\n    keys,\n    i,\n    failingI,\n    error;\n  if (util.isArray(doc)) {\n    this.insertMultipleDocs(doc);\n    return;\n  }\n  key = model.getDotValue(doc, this.fieldName);\n\n  // We don't index documents that don't contain the field if the index is sparse\n  if (key === undefined && this.sparse) {\n    return;\n  }\n  if (!util.isArray(key)) {\n    this.tree.insert(key, doc);\n  } else {\n    // If an insert fails due to a unique constraint, roll back all inserts before it\n    keys = _.uniq(key, projectForUnique);\n    for (i = 0; i < keys.length; i += 1) {\n      try {\n        this.tree.insert(keys[i], doc);\n      } catch (e) {\n        error = e;\n        failingI = i;\n        break;\n      }\n    }\n    if (error) {\n      for (i = 0; i < failingI; i += 1) {\n        this.tree.delete(keys[i], doc);\n      }\n      throw error;\n    }\n  }\n};\n\n/**\n * Insert an array of documents in the index\n * If a constraint is violated, the changes should be rolled back and an error thrown\n *\n * @API private\n */\nIndex.prototype.insertMultipleDocs = function (docs) {\n  var i, error, failingI;\n  for (i = 0; i < docs.length; i += 1) {\n    try {\n      this.insert(docs[i]);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  }\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.remove(docs[i]);\n    }\n    throw error;\n  }\n};\n\n/**\n * Remove a document from the index\n * If an array is passed, we remove all its elements\n * The remove operation is safe with regards to the 'unique' constraint\n * O(log(n))\n */\nIndex.prototype.remove = function (doc) {\n  var key,\n    self = this;\n  if (util.isArray(doc)) {\n    doc.forEach(function (d) {\n      self.remove(d);\n    });\n    return;\n  }\n  key = model.getDotValue(doc, this.fieldName);\n  if (key === undefined && this.sparse) {\n    return;\n  }\n  if (!util.isArray(key)) {\n    this.tree.delete(key, doc);\n  } else {\n    _.uniq(key, projectForUnique).forEach(function (_key) {\n      self.tree.delete(_key, doc);\n    });\n  }\n};\n\n/**\n * Update a document in the index\n * If a constraint is violated, changes are rolled back and an error thrown\n * Naive implementation, still in O(log(n))\n */\nIndex.prototype.update = function (oldDoc, newDoc) {\n  if (util.isArray(oldDoc)) {\n    this.updateMultipleDocs(oldDoc);\n    return;\n  }\n  this.remove(oldDoc);\n  try {\n    this.insert(newDoc);\n  } catch (e) {\n    this.insert(oldDoc);\n    throw e;\n  }\n};\n\n/**\n * Update multiple documents in the index\n * If a constraint is violated, the changes need to be rolled back\n * and an error thrown\n * @param {Array of oldDoc, newDoc pairs} pairs\n *\n * @API private\n */\nIndex.prototype.updateMultipleDocs = function (pairs) {\n  var i, failingI, error;\n  for (i = 0; i < pairs.length; i += 1) {\n    this.remove(pairs[i].oldDoc);\n  }\n  for (i = 0; i < pairs.length; i += 1) {\n    try {\n      this.insert(pairs[i].newDoc);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  }\n\n  // If an error was raised, roll back changes in the inverse order\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.remove(pairs[i].newDoc);\n    }\n    for (i = 0; i < pairs.length; i += 1) {\n      this.insert(pairs[i].oldDoc);\n    }\n    throw error;\n  }\n};\n\n/**\n * Revert an update\n */\nIndex.prototype.revertUpdate = function (oldDoc, newDoc) {\n  var revert = [];\n  if (!util.isArray(oldDoc)) {\n    this.update(newDoc, oldDoc);\n  } else {\n    oldDoc.forEach(function (pair) {\n      revert.push({\n        oldDoc: pair.newDoc,\n        newDoc: pair.oldDoc\n      });\n    });\n    this.update(revert);\n  }\n};\n\n/**\n * Get all documents in index whose key match value (if it is a Thing) or one of the elements of value (if it is an array of Things)\n * @param {Thing} value Value to match the key against\n * @return {Array of documents}\n */\nIndex.prototype.getMatching = function (value) {\n  var self = this;\n  if (!util.isArray(value)) {\n    return self.tree.search(value);\n  } else {\n    var _res = {},\n      res = [];\n    value.forEach(function (v) {\n      self.getMatching(v).forEach(function (doc) {\n        _res[doc._id] = doc;\n      });\n    });\n    Object.keys(_res).forEach(function (_id) {\n      res.push(_res[_id]);\n    });\n    return res;\n  }\n};\n\n/**\n * Get all documents in index whose key is between bounds are they are defined by query\n * Documents are sorted by key\n * @param {Query} query\n * @return {Array of documents}\n */\nIndex.prototype.getBetweenBounds = function (query) {\n  return this.tree.betweenBounds(query);\n};\n\n/**\n * Get all elements in the index\n * @return {Array of documents}\n */\nIndex.prototype.getAll = function () {\n  var res = [];\n  this.tree.executeOnEveryNode(function (node) {\n    var i;\n    for (i = 0; i < node.data.length; i += 1) {\n      res.push(node.data[i]);\n    }\n  });\n  return res;\n};\n\n// Interface\nmodule.exports = Index;","/**\n * Handle models (i.e. docs)\n * Serialization/deserialization\n * Copying\n * Querying, update\n */\n\nvar util = require('util'),\n  _ = require('underscore'),\n  modifierFunctions = {},\n  lastStepModifierFunctions = {},\n  comparisonFunctions = {},\n  logicalOperators = {},\n  arrayComparisonFunctions = {};\n\n/**\n * Check a key, throw an error if the key is non valid\n * @param {String} k key\n * @param {Model} v value, needed to treat the Date edge case\n * Non-treatable edge cases here: if part of the object if of the form { $$date: number } or { $$deleted: true }\n * Its serialized-then-deserialized version it will transformed into a Date object\n * But you really need to want it to trigger such behaviour, even when warned not to use '$' at the beginning of the field names...\n */\nfunction checkKey(k, v) {\n  if (typeof k === 'number') {\n    k = k.toString();\n  }\n  if (k[0] === '$' && !(k === '$$date' && typeof v === 'number') && !(k === '$$deleted' && v === true) && !(k === '$$indexCreated') && !(k === '$$indexRemoved')) {\n    throw new Error('Field names cannot begin with the $ character');\n  }\n  if (k.indexOf('.') !== -1) {\n    throw new Error('Field names cannot contain a .');\n  }\n}\n\n/**\n * Check a DB object and throw an error if it's not valid\n * Works by applying the above checkKey function to all fields recursively\n */\nfunction checkObject(obj) {\n  if (util.isArray(obj)) {\n    obj.forEach(function (o) {\n      checkObject(o);\n    });\n  }\n  if (typeof obj === 'object' && obj !== null) {\n    Object.keys(obj).forEach(function (k) {\n      checkKey(k, obj[k]);\n      checkObject(obj[k]);\n    });\n  }\n}\n\n/**\n * Serialize an object to be persisted to a one-line string\n * For serialization/deserialization, we use the native JSON parser and not eval or Function\n * That gives us less freedom but data entered in the database may come from users\n * so eval and the like are not safe\n * Accepted primitive types: Number, String, Boolean, Date, null\n * Accepted secondary types: Objects, Arrays\n */\nfunction serialize(obj) {\n  var res;\n  res = JSON.stringify(obj, function (k, v) {\n    checkKey(k, v);\n    if (v === undefined) {\n      return undefined;\n    }\n    if (v === null) {\n      return null;\n    }\n\n    // Hackish way of checking if object is Date (this way it works between execution contexts in node-webkit).\n    // We can't use value directly because for dates it is already string in this function (date.toJSON was already called), so we use this\n    if (typeof this[k].getTime === 'function') {\n      return {\n        $$date: this[k].getTime()\n      };\n    }\n    return v;\n  });\n  return res;\n}\n\n/**\n * From a one-line representation of an object generate by the serialize function\n * Return the object itself\n */\nfunction deserialize(rawData) {\n  return JSON.parse(rawData, function (k, v) {\n    if (k === '$$date') {\n      return new Date(v);\n    }\n    if (typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || v === null) {\n      return v;\n    }\n    if (v && v.$$date) {\n      return v.$$date;\n    }\n    return v;\n  });\n}\n\n/**\n * Deep copy a DB object\n * The optional strictKeys flag (defaulting to false) indicates whether to copy everything or only fields\n * where the keys are valid, i.e. don't begin with $ and don't contain a .\n */\nfunction deepCopy(obj, strictKeys) {\n  var res;\n  if (typeof obj === 'boolean' || typeof obj === 'number' || typeof obj === 'string' || obj === null || util.isDate(obj)) {\n    return obj;\n  }\n  if (util.isArray(obj)) {\n    res = [];\n    obj.forEach(function (o) {\n      res.push(deepCopy(o, strictKeys));\n    });\n    return res;\n  }\n  if (typeof obj === 'object') {\n    res = {};\n    Object.keys(obj).forEach(function (k) {\n      if (!strictKeys || k[0] !== '$' && k.indexOf('.') === -1) {\n        res[k] = deepCopy(obj[k], strictKeys);\n      }\n    });\n    return res;\n  }\n  return undefined; // For now everything else is undefined. We should probably throw an error instead\n}\n\n/**\n * Tells if an object is a primitive type or a \"real\" object\n * Arrays are considered primitive\n */\nfunction isPrimitiveType(obj) {\n  return typeof obj === 'boolean' || typeof obj === 'number' || typeof obj === 'string' || obj === null || util.isDate(obj) || util.isArray(obj);\n}\n\n/**\n * Utility functions for comparing things\n * Assumes type checking was already done (a and b already have the same type)\n * compareNSB works for numbers, strings and booleans\n */\nfunction compareNSB(a, b) {\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n}\nfunction compareArrays(a, b) {\n  var i, comp;\n  for (i = 0; i < Math.min(a.length, b.length); i += 1) {\n    comp = compareThings(a[i], b[i]);\n    if (comp !== 0) {\n      return comp;\n    }\n  }\n\n  // Common section was identical, longest one wins\n  return compareNSB(a.length, b.length);\n}\n\n/**\n * Compare { things U undefined }\n * Things are defined as any native types (string, number, boolean, null, date) and objects\n * We need to compare with undefined as it will be used in indexes\n * In the case of objects and arrays, we deep-compare\n * If two objects dont have the same type, the (arbitrary) type hierarchy is: undefined, null, number, strings, boolean, dates, arrays, objects\n * Return -1 if a < b, 1 if a > b and 0 if a = b (note that equality here is NOT the same as defined in areThingsEqual!)\n *\n * @param {Function} _compareStrings String comparing function, returning -1, 0 or 1, overriding default string comparison (useful for languages with accented letters)\n */\nfunction compareThings(a, b, _compareStrings) {\n  var aKeys,\n    bKeys,\n    comp,\n    i,\n    compareStrings = _compareStrings || compareNSB;\n\n  // undefined\n  if (a === undefined) {\n    return b === undefined ? 0 : -1;\n  }\n  if (b === undefined) {\n    return a === undefined ? 0 : 1;\n  }\n\n  // null\n  if (a === null) {\n    return b === null ? 0 : -1;\n  }\n  if (b === null) {\n    return a === null ? 0 : 1;\n  }\n\n  // Numbers\n  if (typeof a === 'number') {\n    return typeof b === 'number' ? compareNSB(a, b) : -1;\n  }\n  if (typeof b === 'number') {\n    return typeof a === 'number' ? compareNSB(a, b) : 1;\n  }\n\n  // Strings\n  if (typeof a === 'string') {\n    return typeof b === 'string' ? compareStrings(a, b) : -1;\n  }\n  if (typeof b === 'string') {\n    return typeof a === 'string' ? compareStrings(a, b) : 1;\n  }\n\n  // Booleans\n  if (typeof a === 'boolean') {\n    return typeof b === 'boolean' ? compareNSB(a, b) : -1;\n  }\n  if (typeof b === 'boolean') {\n    return typeof a === 'boolean' ? compareNSB(a, b) : 1;\n  }\n\n  // Dates\n  if (util.isDate(a)) {\n    return util.isDate(b) ? compareNSB(a.getTime(), b.getTime()) : -1;\n  }\n  if (util.isDate(b)) {\n    return util.isDate(a) ? compareNSB(a.getTime(), b.getTime()) : 1;\n  }\n\n  // Arrays (first element is most significant and so on)\n  if (util.isArray(a)) {\n    return util.isArray(b) ? compareArrays(a, b) : -1;\n  }\n  if (util.isArray(b)) {\n    return util.isArray(a) ? compareArrays(a, b) : 1;\n  }\n\n  // Objects\n  aKeys = Object.keys(a).sort();\n  bKeys = Object.keys(b).sort();\n  for (i = 0; i < Math.min(aKeys.length, bKeys.length); i += 1) {\n    comp = compareThings(a[aKeys[i]], b[bKeys[i]]);\n    if (comp !== 0) {\n      return comp;\n    }\n  }\n  return compareNSB(aKeys.length, bKeys.length);\n}\n\n// ==============================================================\n// Updating documents\n// ==============================================================\n\n/**\n * The signature of modifier functions is as follows\n * Their structure is always the same: recursively follow the dot notation while creating\n * the nested documents if needed, then apply the \"last step modifier\"\n * @param {Object} obj The model to modify\n * @param {String} field Can contain dots, in that case that means we will set a subfield recursively\n * @param {Model} value\n */\n\n/**\n * Set a field to a new value\n */\nlastStepModifierFunctions.$set = function (obj, field, value) {\n  obj[field] = value;\n};\n\n/**\n * Unset a field\n */\nlastStepModifierFunctions.$unset = function (obj, field, value) {\n  delete obj[field];\n};\n\n/**\n * Push an element to the end of an array field\n * Optional modifier $each instead of value to push several values\n * Optional modifier $slice to slice the resulting array, see https://docs.mongodb.org/manual/reference/operator/update/slice/\n * Diffreence with MongoDB: if $slice is specified and not $each, we act as if value is an empty array\n */\nlastStepModifierFunctions.$push = function (obj, field, value) {\n  // Create the array if it doesn't exist\n  if (!obj.hasOwnProperty(field)) {\n    obj[field] = [];\n  }\n  if (!util.isArray(obj[field])) {\n    throw new Error(\"Can't $push an element on non-array values\");\n  }\n  if (value !== null && typeof value === 'object' && value.$slice && value.$each === undefined) {\n    value.$each = [];\n  }\n  if (value !== null && typeof value === 'object' && value.$each) {\n    if (Object.keys(value).length >= 3 || Object.keys(value).length === 2 && value.$slice === undefined) {\n      throw new Error(\"Can only use $slice in cunjunction with $each when $push to array\");\n    }\n    if (!util.isArray(value.$each)) {\n      throw new Error(\"$each requires an array value\");\n    }\n    value.$each.forEach(function (v) {\n      obj[field].push(v);\n    });\n    if (value.$slice === undefined || typeof value.$slice !== 'number') {\n      return;\n    }\n    if (value.$slice === 0) {\n      obj[field] = [];\n    } else {\n      var start,\n        end,\n        n = obj[field].length;\n      if (value.$slice < 0) {\n        start = Math.max(0, n + value.$slice);\n        end = n;\n      } else if (value.$slice > 0) {\n        start = 0;\n        end = Math.min(n, value.$slice);\n      }\n      obj[field] = obj[field].slice(start, end);\n    }\n  } else {\n    obj[field].push(value);\n  }\n};\n\n/**\n * Add an element to an array field only if it is not already in it\n * No modification if the element is already in the array\n * Note that it doesn't check whether the original array contains duplicates\n */\nlastStepModifierFunctions.$addToSet = function (obj, field, value) {\n  var addToSet = true;\n\n  // Create the array if it doesn't exist\n  if (!obj.hasOwnProperty(field)) {\n    obj[field] = [];\n  }\n  if (!util.isArray(obj[field])) {\n    throw new Error(\"Can't $addToSet an element on non-array values\");\n  }\n  if (value !== null && typeof value === 'object' && value.$each) {\n    if (Object.keys(value).length > 1) {\n      throw new Error(\"Can't use another field in conjunction with $each\");\n    }\n    if (!util.isArray(value.$each)) {\n      throw new Error(\"$each requires an array value\");\n    }\n    value.$each.forEach(function (v) {\n      lastStepModifierFunctions.$addToSet(obj, field, v);\n    });\n  } else {\n    obj[field].forEach(function (v) {\n      if (compareThings(v, value) === 0) {\n        addToSet = false;\n      }\n    });\n    if (addToSet) {\n      obj[field].push(value);\n    }\n  }\n};\n\n/**\n * Remove the first or last element of an array\n */\nlastStepModifierFunctions.$pop = function (obj, field, value) {\n  if (!util.isArray(obj[field])) {\n    throw new Error(\"Can't $pop an element from non-array values\");\n  }\n  if (typeof value !== 'number') {\n    throw new Error(value + \" isn't an integer, can't use it with $pop\");\n  }\n  if (value === 0) {\n    return;\n  }\n  if (value > 0) {\n    obj[field] = obj[field].slice(0, obj[field].length - 1);\n  } else {\n    obj[field] = obj[field].slice(1);\n  }\n};\n\n/**\n * Removes all instances of a value from an existing array\n */\nlastStepModifierFunctions.$pull = function (obj, field, value) {\n  var arr, i;\n  if (!util.isArray(obj[field])) {\n    throw new Error(\"Can't $pull an element from non-array values\");\n  }\n  arr = obj[field];\n  for (i = arr.length - 1; i >= 0; i -= 1) {\n    if (match(arr[i], value)) {\n      arr.splice(i, 1);\n    }\n  }\n};\n\n/**\n * Increment a numeric field's value\n */\nlastStepModifierFunctions.$inc = function (obj, field, value) {\n  if (typeof value !== 'number') {\n    throw new Error(value + \" must be a number\");\n  }\n  if (typeof obj[field] !== 'number') {\n    if (!_.has(obj, field)) {\n      obj[field] = value;\n    } else {\n      throw new Error(\"Don't use the $inc modifier on non-number fields\");\n    }\n  } else {\n    obj[field] += value;\n  }\n};\n\n/**\n * Updates the value of the field, only if specified field is greater than the current value of the field\n */\nlastStepModifierFunctions.$max = function (obj, field, value) {\n  if (typeof obj[field] === 'undefined') {\n    obj[field] = value;\n  } else if (value > obj[field]) {\n    obj[field] = value;\n  }\n};\n\n/**\n * Updates the value of the field, only if specified field is smaller than the current value of the field\n */\nlastStepModifierFunctions.$min = function (obj, field, value) {\n  if (typeof obj[field] === 'undefined') {\n    obj[field] = value;\n  } else if (value < obj[field]) {\n    obj[field] = value;\n  }\n};\n\n// Given its name, create the complete modifier function\nfunction createModifierFunction(modifier) {\n  return function (obj, field, value) {\n    var fieldParts = typeof field === 'string' ? field.split('.') : field;\n    if (fieldParts.length === 1) {\n      lastStepModifierFunctions[modifier](obj, field, value);\n    } else {\n      if (obj[fieldParts[0]] === undefined) {\n        if (modifier === '$unset') {\n          return;\n        } // Bad looking specific fix, needs to be generalized modifiers that behave like $unset are implemented\n        obj[fieldParts[0]] = {};\n      }\n      modifierFunctions[modifier](obj[fieldParts[0]], fieldParts.slice(1), value);\n    }\n  };\n}\n\n// Actually create all modifier functions\nObject.keys(lastStepModifierFunctions).forEach(function (modifier) {\n  modifierFunctions[modifier] = createModifierFunction(modifier);\n});\n\n/**\n * Modify a DB object according to an update query\n */\nfunction modify(obj, updateQuery) {\n  var keys = Object.keys(updateQuery),\n    firstChars = _.map(keys, function (item) {\n      return item[0];\n    }),\n    dollarFirstChars = _.filter(firstChars, function (c) {\n      return c === '$';\n    }),\n    newDoc,\n    modifiers;\n  if (keys.indexOf('_id') !== -1 && updateQuery._id !== obj._id) {\n    throw new Error(\"You cannot change a document's _id\");\n  }\n  if (dollarFirstChars.length !== 0 && dollarFirstChars.length !== firstChars.length) {\n    throw new Error(\"You cannot mix modifiers and normal fields\");\n  }\n  if (dollarFirstChars.length === 0) {\n    // Simply replace the object with the update query contents\n    newDoc = deepCopy(updateQuery);\n    newDoc._id = obj._id;\n  } else {\n    // Apply modifiers\n    modifiers = _.uniq(keys);\n    newDoc = deepCopy(obj);\n    modifiers.forEach(function (m) {\n      var keys;\n      if (!modifierFunctions[m]) {\n        throw new Error(\"Unknown modifier \" + m);\n      }\n\n      // Can't rely on Object.keys throwing on non objects since ES6\n      // Not 100% satisfying as non objects can be interpreted as objects but no false negatives so we can live with it\n      if (typeof updateQuery[m] !== 'object') {\n        throw new Error(\"Modifier \" + m + \"'s argument must be an object\");\n      }\n      keys = Object.keys(updateQuery[m]);\n      keys.forEach(function (k) {\n        modifierFunctions[m](newDoc, k, updateQuery[m][k]);\n      });\n    });\n  }\n\n  // Check result is valid and return it\n  checkObject(newDoc);\n  if (obj._id !== newDoc._id) {\n    throw new Error(\"You can't change a document's _id\");\n  }\n  return newDoc;\n}\n;\n\n// ==============================================================\n// Finding documents\n// ==============================================================\n\n/**\n * Get a value from object with dot notation\n * @param {Object} obj\n * @param {String} field\n */\nfunction getDotValue(obj, field) {\n  var fieldParts = typeof field === 'string' ? field.split('.') : field,\n    i,\n    objs;\n  if (!obj) {\n    return undefined;\n  } // field cannot be empty so that means we should return undefined so that nothing can match\n\n  if (fieldParts.length === 0) {\n    return obj;\n  }\n  if (fieldParts.length === 1) {\n    return obj[fieldParts[0]];\n  }\n  if (util.isArray(obj[fieldParts[0]])) {\n    // If the next field is an integer, return only this item of the array\n    i = parseInt(fieldParts[1], 10);\n    if (typeof i === 'number' && !isNaN(i)) {\n      return getDotValue(obj[fieldParts[0]][i], fieldParts.slice(2));\n    }\n\n    // Return the array of values\n    objs = new Array();\n    for (i = 0; i < obj[fieldParts[0]].length; i += 1) {\n      objs.push(getDotValue(obj[fieldParts[0]][i], fieldParts.slice(1)));\n    }\n    return objs;\n  } else {\n    return getDotValue(obj[fieldParts[0]], fieldParts.slice(1));\n  }\n}\n\n/**\n * Check whether 'things' are equal\n * Things are defined as any native types (string, number, boolean, null, date) and objects\n * In the case of object, we check deep equality\n * Returns true if they are, false otherwise\n */\nfunction areThingsEqual(a, b) {\n  var aKeys, bKeys, i;\n\n  // Strings, booleans, numbers, null\n  if (a === null || typeof a === 'string' || typeof a === 'boolean' || typeof a === 'number' || b === null || typeof b === 'string' || typeof b === 'boolean' || typeof b === 'number') {\n    return a === b;\n  }\n\n  // Dates\n  if (util.isDate(a) || util.isDate(b)) {\n    return util.isDate(a) && util.isDate(b) && a.getTime() === b.getTime();\n  }\n\n  // Arrays (no match since arrays are used as a $in)\n  // undefined (no match since they mean field doesn't exist and can't be serialized)\n  if (!(util.isArray(a) && util.isArray(b)) && (util.isArray(a) || util.isArray(b)) || a === undefined || b === undefined) {\n    return false;\n  }\n\n  // General objects (check for deep equality)\n  // a and b should be objects at this point\n  try {\n    aKeys = Object.keys(a);\n    bKeys = Object.keys(b);\n  } catch (e) {\n    return false;\n  }\n  if (aKeys.length !== bKeys.length) {\n    return false;\n  }\n  for (i = 0; i < aKeys.length; i += 1) {\n    if (bKeys.indexOf(aKeys[i]) === -1) {\n      return false;\n    }\n    if (!areThingsEqual(a[aKeys[i]], b[aKeys[i]])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Check that two values are comparable\n */\nfunction areComparable(a, b) {\n  if (typeof a !== 'string' && typeof a !== 'number' && !util.isDate(a) && typeof b !== 'string' && typeof b !== 'number' && !util.isDate(b)) {\n    return false;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Arithmetic and comparison operators\n * @param {Native value} a Value in the object\n * @param {Native value} b Value in the query\n */\ncomparisonFunctions.$lt = function (a, b) {\n  return areComparable(a, b) && a < b;\n};\ncomparisonFunctions.$lte = function (a, b) {\n  return areComparable(a, b) && a <= b;\n};\ncomparisonFunctions.$gt = function (a, b) {\n  return areComparable(a, b) && a > b;\n};\ncomparisonFunctions.$gte = function (a, b) {\n  return areComparable(a, b) && a >= b;\n};\ncomparisonFunctions.$ne = function (a, b) {\n  if (a === undefined) {\n    return true;\n  }\n  return !areThingsEqual(a, b);\n};\ncomparisonFunctions.$in = function (a, b) {\n  var i;\n  if (!util.isArray(b)) {\n    throw new Error(\"$in operator called with a non-array\");\n  }\n  for (i = 0; i < b.length; i += 1) {\n    if (areThingsEqual(a, b[i])) {\n      return true;\n    }\n  }\n  return false;\n};\ncomparisonFunctions.$nin = function (a, b) {\n  if (!util.isArray(b)) {\n    throw new Error(\"$nin operator called with a non-array\");\n  }\n  return !comparisonFunctions.$in(a, b);\n};\ncomparisonFunctions.$regex = function (a, b) {\n  if (!util.isRegExp(b)) {\n    throw new Error(\"$regex operator called with non regular expression\");\n  }\n  if (typeof a !== 'string') {\n    return false;\n  } else {\n    return b.test(a);\n  }\n};\ncomparisonFunctions.$exists = function (value, exists) {\n  if (exists || exists === '') {\n    // This will be true for all values of exists except false, null, undefined and 0\n    exists = true; // That's strange behaviour (we should only use true/false) but that's the way Mongo does it...\n  } else {\n    exists = false;\n  }\n  if (value === undefined) {\n    return !exists;\n  } else {\n    return exists;\n  }\n};\n\n// Specific to arrays\ncomparisonFunctions.$size = function (obj, value) {\n  if (!util.isArray(obj)) {\n    return false;\n  }\n  if (value % 1 !== 0) {\n    throw new Error(\"$size operator called without an integer\");\n  }\n  return obj.length == value;\n};\ncomparisonFunctions.$elemMatch = function (obj, value) {\n  if (!util.isArray(obj)) {\n    return false;\n  }\n  var i = obj.length;\n  var result = false; // Initialize result\n  while (i--) {\n    if (match(obj[i], value)) {\n      // If match for array element, return true\n      result = true;\n      break;\n    }\n  }\n  return result;\n};\narrayComparisonFunctions.$size = true;\narrayComparisonFunctions.$elemMatch = true;\n\n/**\n * Match any of the subqueries\n * @param {Model} obj\n * @param {Array of Queries} query\n */\nlogicalOperators.$or = function (obj, query) {\n  var i;\n  if (!util.isArray(query)) {\n    throw new Error(\"$or operator used without an array\");\n  }\n  for (i = 0; i < query.length; i += 1) {\n    if (match(obj, query[i])) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Match all of the subqueries\n * @param {Model} obj\n * @param {Array of Queries} query\n */\nlogicalOperators.$and = function (obj, query) {\n  var i;\n  if (!util.isArray(query)) {\n    throw new Error(\"$and operator used without an array\");\n  }\n  for (i = 0; i < query.length; i += 1) {\n    if (!match(obj, query[i])) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Inverted match of the query\n * @param {Model} obj\n * @param {Query} query\n */\nlogicalOperators.$not = function (obj, query) {\n  return !match(obj, query);\n};\n\n/**\n * Use a function to match\n * @param {Model} obj\n * @param {Query} query\n */\nlogicalOperators.$where = function (obj, fn) {\n  var result;\n  if (!_.isFunction(fn)) {\n    throw new Error(\"$where operator used without a function\");\n  }\n  result = fn.call(obj);\n  if (!_.isBoolean(result)) {\n    throw new Error(\"$where function must return boolean\");\n  }\n  return result;\n};\n\n/**\n * Tell if a given document matches a query\n * @param {Object} obj Document to check\n * @param {Object} query\n */\nfunction match(obj, query) {\n  var queryKeys, queryKey, queryValue, i;\n\n  // Primitive query against a primitive type\n  // This is a bit of a hack since we construct an object with an arbitrary key only to dereference it later\n  // But I don't have time for a cleaner implementation now\n  if (isPrimitiveType(obj) || isPrimitiveType(query)) {\n    return matchQueryPart({\n      needAKey: obj\n    }, 'needAKey', query);\n  }\n\n  // Normal query\n  queryKeys = Object.keys(query);\n  for (i = 0; i < queryKeys.length; i += 1) {\n    queryKey = queryKeys[i];\n    queryValue = query[queryKey];\n    if (queryKey[0] === '$') {\n      if (!logicalOperators[queryKey]) {\n        throw new Error(\"Unknown logical operator \" + queryKey);\n      }\n      if (!logicalOperators[queryKey](obj, queryValue)) {\n        return false;\n      }\n    } else {\n      if (!matchQueryPart(obj, queryKey, queryValue)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n;\n\n/**\n * Match an object against a specific { key: value } part of a query\n * if the treatObjAsValue flag is set, don't try to match every part separately, but the array as a whole\n */\nfunction matchQueryPart(obj, queryKey, queryValue, treatObjAsValue) {\n  var objValue = getDotValue(obj, queryKey),\n    i,\n    keys,\n    firstChars,\n    dollarFirstChars;\n\n  // Check if the value is an array if we don't force a treatment as value\n  if (util.isArray(objValue) && !treatObjAsValue) {\n    // If the queryValue is an array, try to perform an exact match\n    if (util.isArray(queryValue)) {\n      return matchQueryPart(obj, queryKey, queryValue, true);\n    }\n\n    // Check if we are using an array-specific comparison function\n    if (queryValue !== null && typeof queryValue === 'object' && !util.isRegExp(queryValue)) {\n      keys = Object.keys(queryValue);\n      for (i = 0; i < keys.length; i += 1) {\n        if (arrayComparisonFunctions[keys[i]]) {\n          return matchQueryPart(obj, queryKey, queryValue, true);\n        }\n      }\n    }\n\n    // If not, treat it as an array of { obj, query } where there needs to be at least one match\n    for (i = 0; i < objValue.length; i += 1) {\n      if (matchQueryPart({\n        k: objValue[i]\n      }, 'k', queryValue)) {\n        return true;\n      } // k here could be any string\n    }\n\n    return false;\n  }\n\n  // queryValue is an actual object. Determine whether it contains comparison operators\n  // or only normal fields. Mixed objects are not allowed\n  if (queryValue !== null && typeof queryValue === 'object' && !util.isRegExp(queryValue) && !util.isArray(queryValue)) {\n    keys = Object.keys(queryValue);\n    firstChars = _.map(keys, function (item) {\n      return item[0];\n    });\n    dollarFirstChars = _.filter(firstChars, function (c) {\n      return c === '$';\n    });\n    if (dollarFirstChars.length !== 0 && dollarFirstChars.length !== firstChars.length) {\n      throw new Error(\"You cannot mix operators and normal fields\");\n    }\n\n    // queryValue is an object of this form: { $comparisonOperator1: value1, ... }\n    if (dollarFirstChars.length > 0) {\n      for (i = 0; i < keys.length; i += 1) {\n        if (!comparisonFunctions[keys[i]]) {\n          throw new Error(\"Unknown comparison function \" + keys[i]);\n        }\n        if (!comparisonFunctions[keys[i]](objValue, queryValue[keys[i]])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n\n  // Using regular expressions with basic querying\n  if (util.isRegExp(queryValue)) {\n    return comparisonFunctions.$regex(objValue, queryValue);\n  }\n\n  // queryValue is either a native value or a normal object\n  // Basic matching is possible\n  if (!areThingsEqual(objValue, queryValue)) {\n    return false;\n  }\n  return true;\n}\n\n// Interface\nmodule.exports.serialize = serialize;\nmodule.exports.deserialize = deserialize;\nmodule.exports.deepCopy = deepCopy;\nmodule.exports.checkObject = checkObject;\nmodule.exports.isPrimitiveType = isPrimitiveType;\nmodule.exports.modify = modify;\nmodule.exports.getDotValue = getDotValue;\nmodule.exports.match = match;\nmodule.exports.areThingsEqual = areThingsEqual;\nmodule.exports.compareThings = compareThings;","/**\n * Handle every persistence-related task\n * The interface Datastore expects to be implemented is\n * * Persistence.loadDatabase(callback) and callback has signature err\n * * Persistence.persistNewState(newDocs, callback) where newDocs is an array of documents and callback has signature err\n */\n\nvar storage = require('./storage'),\n  path = require('path'),\n  model = require('./model'),\n  async = require('async'),\n  customUtils = require('./customUtils'),\n  Index = require('./indexes');\n\n/**\n * Create a new Persistence object for database options.db\n * @param {Datastore} options.db\n * @param {Boolean} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where\n *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)\n */\nfunction Persistence(options) {\n  var i, j, randomString;\n  this.db = options.db;\n  this.inMemoryOnly = this.db.inMemoryOnly;\n  this.filename = this.db.filename;\n  this.corruptAlertThreshold = options.corruptAlertThreshold !== undefined ? options.corruptAlertThreshold : 0.1;\n  if (!this.inMemoryOnly && this.filename && this.filename.charAt(this.filename.length - 1) === '~') {\n    throw new Error(\"The datafile name can't end with a ~, which is reserved for crash safe backup files\");\n  }\n\n  // After serialization and before deserialization hooks with some basic sanity checks\n  if (options.afterSerialization && !options.beforeDeserialization) {\n    throw new Error(\"Serialization hook defined but deserialization hook undefined, cautiously refusing to start NeDB to prevent dataloss\");\n  }\n  if (!options.afterSerialization && options.beforeDeserialization) {\n    throw new Error(\"Serialization hook undefined but deserialization hook defined, cautiously refusing to start NeDB to prevent dataloss\");\n  }\n  this.afterSerialization = options.afterSerialization || function (s) {\n    return s;\n  };\n  this.beforeDeserialization = options.beforeDeserialization || function (s) {\n    return s;\n  };\n  for (i = 1; i < 30; i += 1) {\n    for (j = 0; j < 10; j += 1) {\n      randomString = customUtils.uid(i);\n      if (this.beforeDeserialization(this.afterSerialization(randomString)) !== randomString) {\n        throw new Error(\"beforeDeserialization is not the reverse of afterSerialization, cautiously refusing to start NeDB to prevent dataloss\");\n      }\n    }\n  }\n\n  // For NW apps, store data in the same directory where NW stores application data\n  if (this.filename && options.nodeWebkitAppName) {\n    console.log(\"==================================================================\");\n    console.log(\"WARNING: The nodeWebkitAppName option is deprecated\");\n    console.log(\"To get the path to the directory where Node Webkit stores the data\");\n    console.log(\"for your app, use the internal nw.gui module like this\");\n    console.log(\"require('nw.gui').App.dataPath\");\n    console.log(\"See https://github.com/rogerwang/node-webkit/issues/500\");\n    console.log(\"==================================================================\");\n    this.filename = Persistence.getNWAppFilename(options.nodeWebkitAppName, this.filename);\n  }\n}\n;\n\n/**\n * Check if a directory exists and create it on the fly if it is not the case\n * cb is optional, signature: err\n */\nPersistence.ensureDirectoryExists = function (dir, cb) {\n  var callback = cb || function () {};\n  storage.mkdirp(dir, function (err) {\n    return callback(err);\n  });\n};\n\n/**\n * Return the path the datafile if the given filename is relative to the directory where Node Webkit stores\n * data for this application. Probably the best place to store data\n */\nPersistence.getNWAppFilename = function (appName, relativeFilename) {\n  var home;\n  switch (process.platform) {\n    case 'win32':\n    case 'win64':\n      home = process.env.LOCALAPPDATA || process.env.APPDATA;\n      if (!home) {\n        throw new Error(\"Couldn't find the base application data folder\");\n      }\n      home = path.join(home, appName);\n      break;\n    case 'darwin':\n      home = process.env.HOME;\n      if (!home) {\n        throw new Error(\"Couldn't find the base application data directory\");\n      }\n      home = path.join(home, 'Library', 'Application Support', appName);\n      break;\n    case 'linux':\n      home = process.env.HOME;\n      if (!home) {\n        throw new Error(\"Couldn't find the base application data directory\");\n      }\n      home = path.join(home, '.config', appName);\n      break;\n    default:\n      throw new Error(\"Can't use the Node Webkit relative path for platform \" + process.platform);\n      break;\n  }\n  return path.join(home, 'nedb-data', relativeFilename);\n};\n\n/**\n * Persist cached database\n * This serves as a compaction function since the cache always contains only the number of documents in the collection\n * while the data file is append-only so it may grow larger\n * @param {Function} cb Optional callback, signature: err\n */\nPersistence.prototype.persistCachedDatabase = function (cb) {\n  var callback = cb || function () {},\n    toPersist = '',\n    self = this;\n  if (this.inMemoryOnly) {\n    return callback(null);\n  }\n  this.db.getAllData().forEach(function (doc) {\n    toPersist += self.afterSerialization(model.serialize(doc)) + '\\n';\n  });\n  Object.keys(this.db.indexes).forEach(function (fieldName) {\n    if (fieldName != \"_id\") {\n      // The special _id index is managed by datastore.js, the others need to be persisted\n      toPersist += self.afterSerialization(model.serialize({\n        $$indexCreated: {\n          fieldName: fieldName,\n          unique: self.db.indexes[fieldName].unique,\n          sparse: self.db.indexes[fieldName].sparse\n        }\n      })) + '\\n';\n    }\n  });\n  storage.crashSafeWriteFile(this.filename, toPersist, function (err) {\n    if (err) {\n      return callback(err);\n    }\n    self.db.emit('compaction.done');\n    return callback(null);\n  });\n};\n\n/**\n * Queue a rewrite of the datafile\n */\nPersistence.prototype.compactDatafile = function () {\n  this.db.executor.push({\n    this: this,\n    fn: this.persistCachedDatabase,\n    arguments: []\n  });\n};\n\n/**\n * Set automatic compaction every interval ms\n * @param {Number} interval in milliseconds, with an enforced minimum of 5 seconds\n */\nPersistence.prototype.setAutocompactionInterval = function (interval) {\n  var self = this,\n    minInterval = 5000,\n    realInterval = Math.max(interval || 0, minInterval);\n  this.stopAutocompaction();\n  this.autocompactionIntervalId = setInterval(function () {\n    self.compactDatafile();\n  }, realInterval);\n};\n\n/**\n * Stop autocompaction (do nothing if autocompaction was not running)\n */\nPersistence.prototype.stopAutocompaction = function () {\n  if (this.autocompactionIntervalId) {\n    clearInterval(this.autocompactionIntervalId);\n  }\n};\n\n/**\n * Persist new state for the given newDocs (can be insertion, update or removal)\n * Use an append-only format\n * @param {Array} newDocs Can be empty if no doc was updated/removed\n * @param {Function} cb Optional, signature: err\n */\nPersistence.prototype.persistNewState = function (newDocs, cb) {\n  var self = this,\n    toPersist = '',\n    callback = cb || function () {};\n\n  // In-memory only datastore\n  if (self.inMemoryOnly) {\n    return callback(null);\n  }\n  newDocs.forEach(function (doc) {\n    toPersist += self.afterSerialization(model.serialize(doc)) + '\\n';\n  });\n  if (toPersist.length === 0) {\n    return callback(null);\n  }\n  storage.appendFile(self.filename, toPersist, 'utf8', function (err) {\n    return callback(err);\n  });\n};\n\n/**\n * From a database's raw data, return the corresponding\n * machine understandable collection\n */\nPersistence.prototype.treatRawData = function (rawData) {\n  var data = rawData.split('\\n'),\n    dataById = {},\n    tdata = [],\n    i,\n    indexes = {},\n    corruptItems = -1 // Last line of every data file is usually blank so not really corrupt\n  ;\n\n  for (i = 0; i < data.length; i += 1) {\n    var doc;\n    try {\n      doc = model.deserialize(this.beforeDeserialization(data[i]));\n      if (doc._id) {\n        if (doc.$$deleted === true) {\n          delete dataById[doc._id];\n        } else {\n          dataById[doc._id] = doc;\n        }\n      } else if (doc.$$indexCreated && doc.$$indexCreated.fieldName != undefined) {\n        indexes[doc.$$indexCreated.fieldName] = doc.$$indexCreated;\n      } else if (typeof doc.$$indexRemoved === \"string\") {\n        delete indexes[doc.$$indexRemoved];\n      }\n    } catch (e) {\n      corruptItems += 1;\n    }\n  }\n\n  // A bit lenient on corruption\n  if (data.length > 0 && corruptItems / data.length > this.corruptAlertThreshold) {\n    throw new Error(\"More than \" + Math.floor(100 * this.corruptAlertThreshold) + \"% of the data file is corrupt, the wrong beforeDeserialization hook may be used. Cautiously refusing to start NeDB to prevent dataloss\");\n  }\n  Object.keys(dataById).forEach(function (k) {\n    tdata.push(dataById[k]);\n  });\n  return {\n    data: tdata,\n    indexes: indexes\n  };\n};\n\n/**\n * Load the database\n * 1) Create all indexes\n * 2) Insert all data\n * 3) Compact the database\n * This means pulling data out of the data file or creating it if it doesn't exist\n * Also, all data is persisted right away, which has the effect of compacting the database file\n * This operation is very quick at startup for a big collection (60ms for ~10k docs)\n * @param {Function} cb Optional callback, signature: err\n */\nPersistence.prototype.loadDatabase = function (cb) {\n  var callback = cb || function () {},\n    self = this;\n  self.db.resetIndexes();\n\n  // In-memory only datastore\n  if (self.inMemoryOnly) {\n    return callback(null);\n  }\n  async.waterfall([function (cb) {\n    Persistence.ensureDirectoryExists(path.dirname(self.filename), function (err) {\n      storage.ensureDatafileIntegrity(self.filename, function (err) {\n        storage.readFile(self.filename, 'utf8', function (err, rawData) {\n          if (err) {\n            return cb(err);\n          }\n          try {\n            var treatedData = self.treatRawData(rawData);\n          } catch (e) {\n            return cb(e);\n          }\n\n          // Recreate all indexes in the datafile\n          Object.keys(treatedData.indexes).forEach(function (key) {\n            self.db.indexes[key] = new Index(treatedData.indexes[key]);\n          });\n\n          // Fill cached database (i.e. all indexes) with data\n          try {\n            self.db.resetIndexes(treatedData.data);\n          } catch (e) {\n            self.db.resetIndexes(); // Rollback any index which didn't fail\n            return cb(e);\n          }\n          self.db.persistence.persistCachedDatabase(cb);\n        });\n      });\n    });\n  }], function (err) {\n    if (err) {\n      return callback(err);\n    }\n    self.db.executor.processBuffer();\n    return callback(null);\n  });\n};\n\n// Interface\nmodule.exports = Persistence;","/**\n * Way data is stored for this database\n * For a Node.js/Node Webkit database it's the file system\n * For a browser-side database it's localforage which chooses the best option depending on user browser (IndexedDB then WebSQL then localStorage)\n *\n * This version is the Node.js/Node Webkit version\n * It's essentially fs, mkdirp and crash safe write and read functions\n */\n\nvar fs = require('fs'),\n  mkdirp = require('mkdirp'),\n  async = require('async'),\n  path = require('path'),\n  storage = {};\nstorage.exists = fs.exists;\nstorage.rename = fs.rename;\nstorage.writeFile = fs.writeFile;\nstorage.unlink = fs.unlink;\nstorage.appendFile = fs.appendFile;\nstorage.readFile = fs.readFile;\nstorage.mkdirp = mkdirp;\n\n/**\n * Explicit name ...\n */\nstorage.ensureFileDoesntExist = function (file, callback) {\n  storage.exists(file, function (exists) {\n    if (!exists) {\n      return callback(null);\n    }\n    storage.unlink(file, function (err) {\n      return callback(err);\n    });\n  });\n};\n\n/**\n * Flush data in OS buffer to storage if corresponding option is set\n * @param {String} options.filename\n * @param {Boolean} options.isDir Optional, defaults to false\n * If options is a string, it is assumed that the flush of the file (not dir) called options was requested\n */\nstorage.flushToStorage = function (options, callback) {\n  var filename, flags;\n  if (typeof options === 'string') {\n    filename = options;\n    flags = 'r+';\n  } else {\n    filename = options.filename;\n    flags = options.isDir ? 'r' : 'r+';\n  }\n\n  // Windows can't fsync (FlushFileBuffers) directories. We can live with this as it cannot cause 100% dataloss\n  // except in the very rare event of the first time database is loaded and a crash happens\n  if (flags === 'r' && (process.platform === 'win32' || process.platform === 'win64')) {\n    return callback(null);\n  }\n  fs.open(filename, flags, function (err, fd) {\n    if (err) {\n      return callback(err);\n    }\n    fs.fsync(fd, function (errFS) {\n      fs.close(fd, function (errC) {\n        if (errFS || errC) {\n          var e = new Error('Failed to flush to storage');\n          e.errorOnFsync = errFS;\n          e.errorOnClose = errC;\n          return callback(e);\n        } else {\n          return callback(null);\n        }\n      });\n    });\n  });\n};\n\n/**\n * Fully write or rewrite the datafile, immune to crashes during the write operation (data will not be lost)\n * @param {String} filename\n * @param {String} data\n * @param {Function} cb Optional callback, signature: err\n */\nstorage.crashSafeWriteFile = function (filename, data, cb) {\n  var callback = cb || function () {},\n    tempFilename = filename + '~';\n  async.waterfall([async.apply(storage.flushToStorage, {\n    filename: path.dirname(filename),\n    isDir: true\n  }), function (cb) {\n    storage.exists(filename, function (exists) {\n      if (exists) {\n        storage.flushToStorage(filename, function (err) {\n          return cb(err);\n        });\n      } else {\n        return cb();\n      }\n    });\n  }, function (cb) {\n    storage.writeFile(tempFilename, data, function (err) {\n      return cb(err);\n    });\n  }, async.apply(storage.flushToStorage, tempFilename), function (cb) {\n    storage.rename(tempFilename, filename, function (err) {\n      return cb(err);\n    });\n  }, async.apply(storage.flushToStorage, {\n    filename: path.dirname(filename),\n    isDir: true\n  })], function (err) {\n    return callback(err);\n  });\n};\n\n/**\n * Ensure the datafile contains all the data, even if there was a crash during a full file write\n * @param {String} filename\n * @param {Function} callback signature: err\n */\nstorage.ensureDatafileIntegrity = function (filename, callback) {\n  var tempFilename = filename + '~';\n  storage.exists(filename, function (filenameExists) {\n    // Write was successful\n    if (filenameExists) {\n      return callback(null);\n    }\n    storage.exists(tempFilename, function (oldFilenameExists) {\n      // New database\n      if (!oldFilenameExists) {\n        return storage.writeFile(filename, '', 'utf8', function (err) {\n          callback(err);\n        });\n      }\n\n      // Write failed, use old version\n      storage.rename(tempFilename, filename, function (err) {\n        return callback(err);\n      });\n    });\n  });\n};\n\n// Interface\nmodule.exports = storage;","//     Underscore.js 1.4.4\n//     http://underscorejs.org\n//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore may be freely distributed under the MIT license.\n\n(function () {\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype,\n    ObjProto = Object.prototype,\n    FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push = ArrayProto.push,\n    slice = ArrayProto.slice,\n    concat = ArrayProto.concat,\n    toString = ObjProto.toString,\n    hasOwnProperty = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var nativeForEach = ArrayProto.forEach,\n    nativeMap = ArrayProto.map,\n    nativeReduce = ArrayProto.reduce,\n    nativeReduceRight = ArrayProto.reduceRight,\n    nativeFilter = ArrayProto.filter,\n    nativeEvery = ArrayProto.every,\n    nativeSome = ArrayProto.some,\n    nativeIndexOf = ArrayProto.indexOf,\n    nativeLastIndexOf = ArrayProto.lastIndexOf,\n    nativeIsArray = Array.isArray,\n    nativeKeys = Object.keys,\n    nativeBind = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function (obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.4.4';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function (obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function (obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function (value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function (obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function (value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function (obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function (value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function (obj, iterator, context) {\n    var result;\n    any(obj, function (value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function (obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function (value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function (obj, iterator, context) {\n    return _.filter(obj, function (value, index, list) {\n      return !iterator.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function (obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function (value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function (obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function (value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function (obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function (value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function (obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function (value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function (obj, key) {\n    return _.map(obj, function (value) {\n      return value[key];\n    });\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function (obj, attrs, first) {\n    if (_.isEmpty(attrs)) return first ? null : [];\n    return _[first ? 'find' : 'filter'](obj, function (value) {\n      for (var key in attrs) {\n        if (attrs[key] !== value[key]) return false;\n      }\n      return true;\n    });\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function (obj, attrs) {\n    return _.where(obj, attrs, true);\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\n  _.max = function (obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {\n      computed: -Infinity,\n      value: -Infinity\n    };\n    each(obj, function (value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {\n        value: value,\n        computed: computed\n      });\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function (obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {\n      computed: Infinity,\n      value: Infinity\n    };\n    each(obj, function (value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {\n        value: value,\n        computed: computed\n      });\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function (obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function (value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function (value) {\n    return _.isFunction(value) ? value : function (obj) {\n      return obj[value];\n    };\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function (obj, value, context) {\n    var iterator = lookupIterator(value);\n    return _.pluck(_.map(obj, function (value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iterator.call(context, value, index, list)\n      };\n    }).sort(function (left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index < right.index ? -1 : 1;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function (obj, value, context, behavior) {\n    var result = {};\n    var iterator = lookupIterator(value || _.identity);\n    each(obj, function (value, index) {\n      var key = iterator.call(context, value, index, obj);\n      behavior(result, key, value);\n    });\n    return result;\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function (obj, value, context) {\n    return group(obj, value, context, function (result, key, value) {\n      (_.has(result, key) ? result[key] : result[key] = []).push(value);\n    });\n  };\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = function (obj, value, context) {\n    return group(obj, value, context, function (result, key) {\n      if (!_.has(result, key)) result[key] = 0;\n      result[key]++;\n    });\n  };\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function (array, obj, iterator, context) {\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0,\n      high = array.length;\n    while (low < high) {\n      var mid = low + high >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function (obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function (obj) {\n    if (obj == null) return 0;\n    return obj.length === +obj.length ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function (array, n, guard) {\n    if (array == null) return void 0;\n    return n != null && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function (array, n, guard) {\n    return slice.call(array, 0, array.length - (n == null || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function (array, n, guard) {\n    if (array == null) return void 0;\n    if (n != null && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function (array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function (array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function (input, shallow, output) {\n    each(input, function (value) {\n      if (_.isArray(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function (array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function (array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function (array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function (value, index) {\n      if (isSorted ? !index || seen[seen.length - 1] !== value : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function () {\n    return _.uniq(concat.apply(ArrayProto, arguments));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function (array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function (item) {\n      return _.every(rest, function (other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function (array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function (value) {\n      return !_.contains(rest, value);\n    });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function () {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(args, \"\" + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function (list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function (array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0,\n      l = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = isSorted < 0 ? Math.max(0, l + isSorted) : isSorted;\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function (array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = hasIndex ? from : array.length;\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function (start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n    while (idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function (func, context) {\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    var args = slice.call(arguments, 2);\n    return function () {\n      return func.apply(context, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context.\n  _.partial = function (func) {\n    var args = slice.call(arguments, 1);\n    return function () {\n      return func.apply(this, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function (obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length === 0) funcs = _.functions(obj);\n    each(funcs, function (f) {\n      obj[f] = _.bind(obj[f], obj);\n    });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function (func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function () {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : memo[key] = func.apply(this, arguments);\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function (func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function () {\n      return func.apply(null, args);\n    }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function (func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function (func, wait) {\n    var context, args, timeout, result;\n    var previous = 0;\n    var later = function () {\n      previous = new Date();\n      timeout = null;\n      result = func.apply(context, args);\n    };\n    return function () {\n      var now = new Date();\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n      } else if (!timeout) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function (func, wait, immediate) {\n    var timeout, result;\n    return function () {\n      var context = this,\n        args = arguments;\n      var later = function () {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) result = func.apply(context, args);\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function (func) {\n    var ran = false,\n      memo;\n    return function () {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function (func, wrapper) {\n    return function () {\n      var args = [func];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function () {\n    var funcs = arguments;\n    return function () {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function (times, func) {\n    if (times <= 0) return func();\n    return function () {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function (obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function (obj) {\n    var values = [];\n    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function (obj) {\n    var pairs = [];\n    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function (obj) {\n    var result = {};\n    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function (obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function (obj) {\n    each(slice.call(arguments, 1), function (source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function (obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function (key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n  // Return a copy of the object without the blacklisted properties.\n  _.omit = function (obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function (obj) {\n    each(slice.call(arguments, 1), function (source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] == null) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function (obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function (obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function (a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0,\n      result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // from different frames are.\n      var aCtor = a.constructor,\n        bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor)) {\n        return false;\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !size--) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function (a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function (obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function (obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function (obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function (obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function (name) {\n    _['is' + name] = function (obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function (obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof /./ !== 'function') {\n    _.isFunction = function (obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function (obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function (obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function (obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function (obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function (obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function (obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function () {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function (value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function (n, iterator, context) {\n    var accum = Array(n);\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function (min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;',\n      '/': '&#x2F;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape: new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function (method) {\n    _[method] = function (string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function (match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function (object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function (obj) {\n    each(_.functions(obj), function (name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function () {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function (prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate: /<%([\\s\\S]+?)%>/g,\n    interpolate: /<%=([\\s\\S]+?)%>/g,\n    escape: /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\": \"'\",\n    '\\\\': '\\\\',\n    '\\r': 'r',\n    '\\n': 'n',\n    '\\t': 't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function (text, data, settings) {\n    var render;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escaper, function (match) {\n        return '\\\\' + escapes[match];\n      });\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n    source = \"var __t,__p='',__j=Array.prototype.join,\" + \"print=function(){__p+=__j.call(arguments,'');};\\n\" + source + \"return __p;\\n\";\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n    if (data) return render(data, _);\n    var template = function (data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function (obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function (obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function () {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function (name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function () {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n  _.extend(_.prototype, {\n    // Start chaining a wrapped Underscore object.\n    chain: function () {\n      this._chain = true;\n      return this;\n    },\n    // Extracts the result from a wrapped and chained object.\n    value: function () {\n      return this._wrapped;\n    }\n  });\n}).call(this);","const { app } = require(\"electron\");\r\nconst path = require(\"path\");\r\nconst fs = require(\"fs\");\r\n\r\nconst Database = require(\"better-sqlite3\");\r\n/*\r\nconst {\r\n  agregarNombreEnDB\r\n} = require(\"./sqliteprueba\");\r\n\r\n\r\n*/\r\nconst {\r\n  splitText,\r\n  convertLastFiveColumns,\r\n  splitTextTitulo,\r\n  SubcadenaAGuionBajo\r\n} = require(\"../../utils/TextFormater\");\r\n\r\nconst {\r\n  obtenerFechaMedicion,\r\n  obtenerYearFromDate,\r\n  obtenerMonthFromDate\r\n} = require(\"../../utils/fecha\");\r\n\r\nconst {\r\n  readFilesInFolder\r\n} = require(\"./LoadDatabase_BSQLITE3\");\r\n\r\n\r\nconst {\r\n  leerNumeroPartnb,\r\n  actualizarNumeroPartnb\r\n} = require(\"./PartnBToDB_NEDB\");\r\n\r\nconst { saveContenidoDataToDB } = require(\"./SaveCHRtoDatabase_BSQLITE3\");\r\n\r\nconst { saveTituloDataToDB } = require(\"./SaveHDRtoDatabase_BSQLITE3\");\r\n\r\n\r\n\r\n//busca ultimo numero de indice partnb\r\nlet partNumber = 0;\r\nleerNumeroPartnb((numero) => {\r\n  partNumber = numero;\r\n  console.log(\"Nmero ledo:\", partNumber);\r\n});\r\n\r\nfunction checkForTildeFiles(ubicacion) {\r\n  //console.log(fs.readdirSync());\r\n  return fs.readdirSync(ubicacion).some((file) => file.includes(\"~\"));\r\n}\r\n\r\nasync function waitUntilFilesRemoved(ubicacion) {\r\n  //console.log(\"////////////////// control //////////////////////\")\r\n  while (!checkForTildeFiles(ubicacion)) {\r\n    console.log(\"///// control ///// - carpeta:\", ubicacion);\r\n    await new Promise((resolve) => setTimeout(resolve, 1000)); // Esperar 1 segundo\r\n  }\r\n}\r\n\r\n//const dbpath = 'mi_basede_datos.db';\r\n//const nombre = 'alfredo';\r\n\r\n//levanta archivos segun direccion enviada desde react a main y los formatea y graba en base de datos nedb\r\n\r\nconst userData = app.getAppPath(); // Obtn la ubicacin de la aplicacin\r\n\r\nasync function SaveFilesToDB(ubicacion) {\r\n  const archivos = fs\r\n    .readdirSync(ubicacion)\r\n    .filter((file) => path.extname(file) === \".txt\" && file.includes(\"_chr\"));\r\n\r\n  for (const archivo of archivos) {\r\n    //await waitUntilFilesRemoved(\"C:\\\\Users\\\\vwari8y.VW\\\\Documents\\\\informesCZ\\\\prueba4\\\\Electron-React-NeDB\\\\data\\\\\");\r\n    let archivoTitulo = archivo.replace(\"_chr\", \"_hdr\");\r\n\r\n    // graba titulo + nombre de archivo\r\n    let Titulo = fs.readFileSync(path.join(ubicacion, archivoTitulo), \"utf8\");\r\n    const date = obtenerFechaMedicion(Titulo);\r\n    const year = obtenerYearFromDate(date);\r\n    const month = obtenerMonthFromDate(date);\r\n\r\n    console.log(\"archivo :\", archivoTitulo);\r\n\r\n    const dbPath = path.join(\r\n      userData,\r\n      `./data/${SubcadenaAGuionBajo(archivoTitulo)}_${year}_${month}.db`\r\n    );\r\n    console.log(\"dbpath:\",readFilesInFolder)\r\n\r\n    if (!fs.existsSync(dbPath)) {\r\n      fs.writeFileSync(dbPath, \"\"); // Crear archivo vaco\r\n    }\r\n\r\n    //---------------graba contenido\r\n    let contenido = fs.readFileSync(path.join(ubicacion, archivo), \"utf8\");\r\n    let tituloToDB = splitTextTitulo(Titulo, partNumber);\r\n\r\n    //funcionando\r\n    try {\r\n      await saveTituloDataToDB(  tituloToDB, dbPath);\r\n       //console.log(\" titulo\",tituloToDB);\r\n    } catch (error) {\r\n      console.error(\"Error 91:\", error);\r\n    }\r\n\r\n    try {\r\n      await saveContenidoDataToDB(\r\n        convertLastFiveColumns(splitText(contenido)),\r\n        partNumber,\r\n        dbPath\r\n      );\r\n      // console.log(\". \",convertLastFiveColumns(splitText(contenido)));\r\n    } catch (error) {}\r\n\r\n    // Llamar a la funcin para agregar el nombre \"alfredo\" en la base de datos \"mi_basede_datos.db\"\r\n\r\n    //agregarNombreEnDB(dbPath, \"Alfredo\");\r\n\r\n    console.log(\"partNumber:\", partNumber);\r\n\r\n    //await delay(500); // delay pro el problema con neDB por la sincronia.. cambiar al cambiar base de datos\r\n\r\n    partNumber++;\r\n  }\r\n\r\n  actualizarNumeroPartnb(partNumber);\r\n  console.log(\"- termino -\");\r\n\r\n\r\n  //--- load ----\r\n  const dbFolder = path.join(\r\n    userData,`./data/`\r\n  );\r\n  //const dbFolder = \"../../../../data/\"; // Cambia esto a la ruta correcta\r\n  const fileData = await readFilesInFolder(dbFolder);\r\n  //console.log(fileData);\r\n\r\n\r\n  \r\n}\r\n\r\n\r\n\r\nmodule.exports = {\r\n  SaveFilesToDB\r\n};\r\n\r\n\r\n/*-------------------------- async y await -------------------\r\n Cuando se declara una funcin como async, automticamente devuelve una promesa. \r\n Esto significa que se puede utilizar await dentro de la funcin \r\n para esperar a que se resuelva una promesa y obtener su resultado de forma sincrnica.\r\n \r\n Al utilizar la palabra clave await antes de una expresin de promesa, \r\n la funcin se detiene en ese punto hasta que la promesa se resuelva o se rechace\r\n\r\nAl llamar a una funcin async, se obtiene una promesa que representa la ejecucin de la funcin. Esto permite utilizar mtodos \r\ncomo .then() y .catch() para manejar la resolucin o el rechazo de la promesa devuelta por la funcin async.\r\n */\r\n\r\n\r\n\r\n//imprecion de objeto\r\n/*const imprimirArrayObjetos = (arrayObjetos) => {\r\n  arrayObjetos.forEach((objeto, index) => {\r\n    console.log(`Objeto ${index + 1}:`);\r\n    Object.entries(objeto).forEach(([clave, valor]) => {\r\n      console.log(`  ${clave}: ${valor}`);\r\n    });\r\n    console.log(\"-----------------------\");\r\n  });\r\n};*/\r\n\r\n\r\n","const fs = require(\"fs\");\r\nconst path = require(\"path\");\r\nconst Database = require(\"better-sqlite3\");\r\n\r\nasync function readFilesInFolder(dbFolderPath) {\r\n  const files = fs.readdirSync(dbFolderPath);\r\n  const result = [];\r\n\r\n  for (const file of files) {\r\n    const filePath = path.join(dbFolderPath, file);\r\n    if (fs.statSync(filePath).isFile()) {\r\n      const db = new Database(filePath, { verbose: console.log });\r\n      const stmt = db.prepare('SELECT date, time, partcomment, orden FROM title');\r\n      const rows = stmt.all();\r\n\r\n      result.push({\r\n        //fileName: file,\r\n        data: rows\r\n      });\r\n      console.log(\"* row loaded:\",rows)\r\n\r\n      db.close();\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  readFilesInFolder\r\n};\r\n\r\n\r\n\r\n","const Datastore = require('nedb');\r\n\r\nfunction leerNumeroPartnb(callback) {\r\n  // Crear o cargar la base de datos 'partnb.db'\r\n  const db2 = new Datastore({ filename: \"./src/services/database/partnb.db\", autoload: true });\r\n\r\n  // Leer el nmero de la base de datos\r\n  db2.findOne({}, (err, doc) => {\r\n    if (err) {\r\n      console.error(\"Error al leer el nmero:\", err);\r\n      return;\r\n    }\r\n    let numero = 0;\r\n\r\n    // Si se encontr un documento, obtener el nmero\r\n    if (doc) {\r\n      numero = doc.numero;\r\n    }\r\n\r\n    // Llamar al callback con el valor de numero si se proporciona un callback\r\n    if (typeof callback === 'function') {\r\n      callback(numero);\r\n    }\r\n  });\r\n}\r\n\r\n\r\n  function actualizarNumeroPartnb(numero) {\r\n    // Incrementar el nmero en uno\r\n    const numeroActualizado = numero;\r\n  \r\n    // Crear o cargar la base de datos 'partnb.db'\r\n    const db2 = new Datastore({ filename: \"./src/services/database/partnb.db\", autoload: true });\r\n  \r\n    // Actualizar el nmero en la base de datos\r\n    db2.update({}, { numero: numeroActualizado }, { upsert: true }, (err, numReplaced) => {\r\n      if (err) {\r\n        console.error(\"Error al actualizar el nmero:\", err);\r\n        return;\r\n      }\r\n      console.log(\"Nmero actualizado:\", numeroActualizado);\r\n    });\r\n  }\r\n  \r\n\r\nmodule.exports = {\r\n    leerNumeroPartnb,\r\n    actualizarNumeroPartnb\r\n};","const sqlite = require('better-sqlite3');\r\n\r\nasync function saveContenidoDataToDB(data, partnb, dbPath) {\r\n  const db = new sqlite(dbPath);\r\n\r\n  try {\r\n    const columnNames = data[0].slice(2).map((columnName, index) => columnName);\r\n    \r\n    const createTableStmt = db.prepare(`\r\n      CREATE TABLE IF NOT EXISTS mediciones (\r\n        id INTEGER PRIMARY KEY,\r\n        partnb TEXT,\r\n        ${columnNames.map(column => `${column} TEXT`).join(', ')}\r\n      )\r\n    `);\r\n\r\n    createTableStmt.run();\r\n\r\n    const insertStmt = db.prepare(`\r\n      INSERT INTO mediciones (partnb, ${columnNames.join(', ')})\r\n      VALUES (?, ${Array(columnNames.length).fill('?').join(', ')})\r\n    `);\r\n\r\n    db.transaction(() => {\r\n      data.forEach((row, index) => {\r\n        const documentExt = BucleRow(row, partnb);\r\n        const insertValues = [partnb, ...documentExt.slice(1).map(value => value !== undefined ? value : null)];\r\n        console.log(\"\")\r\n\r\n        if (index === 0) {\r\n          \r\n        }else if (insertValues.length === columnNames.length + 1) {\r\n          insertStmt.run(insertValues);\r\n        } else {\r\n          //console.log(\"error en:\",insertValues ,\"no se agrego.. ver a futuro\")\r\n          //console.error(\"Error: Insufficient insert values provided _  insertValues.length:\"+insertValues.length + \" columnNames.length:\"+ columnNames.length);\r\n        }\r\n      });\r\n    })();\r\n\r\n  } catch (error) {\r\n    console.error(\"Error al insertar en la base de datos:\", error);\r\n    throw error;\r\n  } finally {\r\n    db.close();\r\n  }\r\n}\r\n\r\nfunction BucleRow(row, partnb) {\r\n  const document = [partnb];\r\n\r\n  const properties = row.slice(2);\r\n  for (let index = 0; index < properties.length; index++) {\r\n    document.push(properties[index]);\r\n  }\r\n\r\n  return document;\r\n}\r\n\r\nmodule.exports = {\r\n  saveContenidoDataToDB\r\n};\r\n","const sqlite = require(\"better-sqlite3\");\r\n\r\n// Define an asynchronous function to save 'tituloToDB' data to the database\r\nasync function saveTituloDataToDB(tituloToDB, dbPath) {\r\n  const db = new sqlite(dbPath);\r\n\r\n  try {\r\n    // Extract the column names from 'tituloToDB', excluding the 'filename' key\r\n    const columnNames = Object.keys(tituloToDB).filter(\r\n      (key) => key !== \"filename\"\r\n    );\r\n\r\n    // Create a comma-separated string of insert columns for the SQL statement\r\n    const insertColumns = columnNames.join(\", \");\r\n\r\n    // Create an array of values to be inserted into the database\r\n    const insertValues = columnNames.map((key) => tituloToDB[key]);\r\n\r\n    // Prepare an SQL statement to create the 'title' table if it doesn't exist\r\n    const createTableStmt = db.prepare(`\r\n      CREATE TABLE IF NOT EXISTS title (\r\n        id INTEGER PRIMARY KEY,\r\n        ${columnNames.map((aux, index) => `${aux} TEXT`).join(\", \")}\r\n      )\r\n    `);\r\n\r\n    // Execute the 'CREATE TABLE' statement\r\n    createTableStmt.run();\r\n\r\n    const insertStmt = db.prepare(`\r\n      INSERT INTO title (${insertColumns}) VALUES (${Array.from(\r\n      { length: columnNames.length },\r\n      () => \"?\"\r\n    ).join(\", \")})\r\n    `);\r\n\r\n    // Use a transaction to execute the insert statement with the values\r\n    db.transaction(() => {\r\n      insertStmt.run(...insertValues);\r\n    })();\r\n  } catch (error) {\r\n    console.error(\"Error al insertar en la base de datos:\", error);\r\n    throw error;\r\n  } finally {\r\n    db.close();\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  saveTituloDataToDB\r\n};\r\n","const Datastore = require(\"nedb\");\r\n\r\nconst { buscarArchivosEnCarpeta } = require(\"../files/files\");\r\n\r\n\r\n\r\nasync function obtenerRegistrosEncontrados() {\r\n  try {\r\n    // Primero, buscamos y obtenemos los nombres de los archivos en la carpeta './data'\r\n    const resultadosArchivos = await buscarArchivosEnCarpeta();\r\n    // Luego, buscamos y obtenemos los campos date, time y partnb de los archivos encontrados\r\n    const resultadosBusqueda = await buscarFechaTiempoYPartnb(  resultadosArchivos.archivosEncontrados );\r\n    // Retornamos los resultados como un objeto\r\n    return resultadosBusqueda;\r\n  } catch (error) {\r\n    console.error(\"Error:\", error);\r\n    return { error };\r\n  }\r\n}\r\n\r\n\r\n\r\n/*\r\nbuscarArchivosEnCarpeta()\r\n  .then((resultados) => {\r\n    //console.log(\"Archivos encontrados:\", resultados.archivosEncontrados);\r\n\r\n    buscarFechaTiempoYPartnb(resultados.archivosEncontrados).then(\r\n      (resultados) => {\r\n        //console.log(\"Resultados:\", resultados);\r\n      }\r\n    );\r\n  })\r\n  .catch((error) => {\r\n    console.error(\"Error:\", error);\r\n  });*/\r\n\r\n// Funcin para buscar y obtener los campos date, time y partnb de mltiples bases de datos\r\nasync function buscarFechaTiempoYPartnb(dbPaths) {\r\n  const promesas = dbPaths.map((dbPath) => {\r\n    return new Promise((resolve, reject) => {\r\n      const db = new Datastore({ filename: dbPath, autoload: true });\r\n      db.find({}, { date: 1, time: 1, partnb: 1, _id: 0 }, (err, registros) => {\r\n        if (err) {\r\n          console.error(\"Error al buscar en la base de datos:\", err);\r\n          resolve({  dbPath, error: err });\r\n        } else {\r\n          // Crea un objeto para almacenar los valores encontrados\r\n          const valoresEncontrados = {\r\n            dates: [],\r\n            times: [],\r\n            partnbs: [],\r\n            path: []\r\n          };\r\n\r\n          // Extrae los campos date, time y partnb de los registros encontrados\r\n          for (const registro of registros) {\r\n            if (registro.date && registro.time && registro.partnb) {\r\n              valoresEncontrados.dates.push(registro.date);\r\n              valoresEncontrados.times.push(registro.time);\r\n              valoresEncontrados.partnbs.push(registro.partnb);\r\n              valoresEncontrados.path.push(dbPath);\r\n            }\r\n          }\r\n\r\n          // Muestra los datos encontrados en la consola\r\n          /*console.log(\"Fechas encontradas:\", valoresEncontrados.dates);\r\n          console.log(\"Tiempos encontrados:\", valoresEncontrados.times);\r\n          console.log(\"Partnbs encontrados:\", valoresEncontrados.partnbs);\r\n          console.log(\"path encontrados:\", valoresEncontrados.path);*/\r\n\r\n          resolve({\r\n            dbPath,\r\n            data: valoresEncontrados\r\n          });\r\n        }\r\n      });\r\n    });\r\n  });\r\n\r\n  try {\r\n    const resultados = await Promise.all(promesas);\r\n    return resultados;\r\n  } catch (error) {\r\n    console.error(\"Error al buscar en las bases de datos:\", error);\r\n    return [];\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  buscarFechaTiempoYPartnb,\r\n  obtenerRegistrosEncontrados\r\n};\r\n\r\n// Llamada a la funcin para buscar y mostrar los datos\r\n","const fs = require('fs');\r\nconst path = require('path');\r\n\r\n// Funcin para buscar y devolver los nombres de todos los archivos en la carpeta './data'\r\nfunction buscarArchivosEnCarpeta() {\r\n    return new Promise((resolve, reject) => {\r\n      const directorio = './data';\r\n      const archivosEncontrados = [];\r\n  \r\n      // Lee el contenido del directorio\r\n      fs.readdir(directorio, (err, archivos) => {\r\n        if (err) {\r\n          console.error('Error al leer el directorio:', err);\r\n          reject(err);\r\n        } else {\r\n          // Itera sobre los archivos encontrados\r\n          archivos.forEach((archivo) => {\r\n            // Verifica si es un archivo\r\n            const rutaArchivo = path.join(directorio, archivo);\r\n            fs.stat(rutaArchivo, (err, stats) => {\r\n              if (err) {\r\n                console.error('Error al obtener informacin del archivo:', err);\r\n              } else {\r\n                if (stats.isFile()) {\r\n                  archivosEncontrados.push(directorio+\"/\"+archivo); // Agrega el nombre del archivo al array\r\n                }\r\n              }\r\n  \r\n              // Si todos los archivos se han verificado, resuelve la promesa con los resultados\r\n              if (archivosEncontrados.length === archivos.length) {\r\n                const resultados = {\r\n                  archivosEncontrados,\r\n                };\r\n                resolve(resultados);\r\n              }\r\n            });\r\n          });\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  function checkFolderExists(folderPath) {\r\n    try {\r\n      const stats = fs.statSync(folderPath);\r\n      return stats.isDirectory();\r\n    } catch (error) {\r\n      if (error.code === 'ENOENT') {\r\n        return false; // El directorio no existe\r\n      }\r\n      throw error; // Manejar otros errores\r\n    }\r\n  }\r\n  \r\n\r\nmodule.exports = {\r\n    buscarArchivosEnCarpeta\r\n  \r\n  };","function splitText(text) {\r\n  const rows = text.split(\"\\n\"); // Divide el texto en filas utilizando el carcter de nueva lnea ('\\n')\r\n  const result = []; // Matriz vaca para almacenar el resultado\r\n\r\n  for (let i = 0; i < rows.length; i++) {\r\n    const columns = rows[i].split(\"\\t\"); // Divide cada fila en columnas utilizando el carcter de tabulacin ('\\t')\r\n    const slicedColumns = columns.slice(0, 4).concat(columns.slice(5, 9)); // Obtiene un subconjunto de columnas segn los ndices especificados\r\n    result.push(slicedColumns); // Agrega las columnas al resultado\r\n  }\r\n\r\n  return result; // Devuelve la matriz resultante\r\n}\r\n\r\nfunction splitTextTitulo(text, partnb) {\r\n  //funcion que toma un string lo separa en filas y columnas, busca palabras claves y devuelve\r\n  //en un objeto el valor de esas palabras que es tomado sobre la misma columna un renglon adelante\r\n\r\n  //const rows = text.split(\"\\n\");\r\n  let rows = text.split(\"\\n\");\r\n\r\n  // Cambia \"order\" por \"orden\"\r\n  rows = rows.map((row) => row.replace(\"order\", \"orden\"));\r\n\r\n  const datosTituloInformeObj = {};\r\n\r\n  //console.log()\r\n  const palabrasClave = [\r\n    \"filename\",\r\n    \"operid\",\r\n    \"date\",\r\n    \"time\",\r\n    \"dmesn\",\r\n    \"partcomment\",\r\n    \"orden\",\r\n    \"temperatureworkpiece\"\r\n  ];\r\n\r\n  for (let i = 0; i < rows.length - 1; i++) {\r\n    const columns = rows[i].split(\"\\t\");\r\n    const nextRowColumns = rows[i + 1].split(\"\\t\");\r\n\r\n    for (let j = 0; j < columns.length; j++) {\r\n      const palabra = columns[j];\r\n\r\n      if (palabrasClave.includes(palabra)) {\r\n        const valor = nextRowColumns[j];\r\n        datosTituloInformeObj[palabra] = valor;\r\n      }\r\n    }\r\n  }\r\n\r\n  //agrega numero que usamos como indice partnb\r\n  datosTituloInformeObj[\"partnb\"] = partnb;\r\n  //console.log(\"Valores en el objeto datosTituloInformeObj:\");\r\n  //console.log(datosTituloInformeObj);\r\n  //console.log(datosTituloInformeObj);\r\n  return datosTituloInformeObj;\r\n}\r\n\r\nfunction obtenerDatosColumnasTexto(text, columna) {\r\n  const rows = text.split(\"\\n\");\r\n\r\n  if (rows.length >= 2) {\r\n    const columns = rows[1].split(\"\\t\");\r\n\r\n    if (columns.length >= 5) {\r\n      //console.log(\"***fecha\", columns[4]);\r\n      return columns[columna]; // Valor de la columna 4, fila 2\r\n    }\r\n  }\r\n\r\n  return null; // Si no se encuentra el valor deseado\r\n}\r\n\r\nfunction convertLastFiveColumns(data) {\r\n  const newData = [];\r\n  \r\n\r\n\r\n  for (let i = 0; i < data.length; i++) {\r\n    const row = data[i];\r\n    const newRow = row.slice();\r\n\r\n    for (let j = newRow.length - 6; j < newRow.length; j++) {\r\n      const value = newRow[j];\r\n\r\n      if (!isNaN(Number(value))) {\r\n        const parsedValue = Number(value).toFixed(3);\r\n        newRow[j] = parsedValue.toString();\r\n      }\r\n\r\n\r\n      // CAMBIA POR SER PALABRA RESERVADA PARA LITESQL\r\n      if (newRow[j] === 'id') {\r\n        newRow[j] = 'idmeasurement'; // Cambiar \"idmeasurement\" a \"id\"\r\n       \r\n      }\r\n\r\n    }\r\n\r\n    \r\n  \r\n    newData.push(newRow);\r\n  }\r\n   //console.log(\"*\",newData)\r\n  return newData;\r\n}\r\n\r\n// esta funcion devuelve todo el texto hasta que aparece el primer \"_\" es para depurar el nombre de los archivos leidos\r\n\r\nfunction SubcadenaAGuionBajo(texto) {\r\n  const indiceGuionBajo = texto.indexOf(\"_\");\r\n  if (indiceGuionBajo !== -1) {\r\n    return texto.slice(0, indiceGuionBajo);\r\n  } else {\r\n    return texto;\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  SubcadenaAGuionBajo,\r\n  splitText,\r\n  convertLastFiveColumns,\r\n  splitTextTitulo,\r\n  obtenerDatosColumnasTexto\r\n};\r\n","\r\n  // Funcin para obtener el ao de una fecha\r\nfunction obtenerYearFromDate(fecha) {\r\n    const partes = fecha.split(\"-\");\r\n    return partes[0];\r\n  }\r\n  \r\n  // Funcin para obtener el mes de una fecha\r\n  function obtenerMonthFromDate(fecha) {\r\n    const partes = fecha.split(\"-\");\r\n    return partes[1];\r\n  }\r\n\r\n\r\n  function obtenerFechaMedicion(text) {\r\n    const rows = text.split(\"\\n\");\r\n  \r\n    if (rows.length >= 2) {\r\n      const columns = rows[1].split(\"\\t\");\r\n  \r\n      if (columns.length >= 5) {\r\n        //console.log(\"***fecha\", columns[4]);\r\n        return columns[4]; // Valor de la columna 4, fila 2\r\n      }\r\n    }\r\n  \r\n    return null; // Si no se encuentra el valor deseado\r\n  }\r\n\r\n  module.exports = {\r\n    obtenerFechaMedicion,\r\n    obtenerYearFromDate,\r\n    obtenerMonthFromDate\r\n\r\n    \r\n  };","module.exports = require(\"crypto\");","module.exports = require(\"electron\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","module.exports = require(\"util\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","const { app, BrowserWindow } = require(\"electron\");\r\n\r\nconst { ipcMain } = require(\"electron\");\r\n\r\nconst { SaveFilesToDB } = require(\"./services/database/FilesToDb\");\r\n\r\nconst { obtenerRegistrosEncontrados } = require(\"./services/database/loadDB_NEDB\");\r\n\r\n// Handle creating/removing shortcuts on Windows when installing/uninstalling.\r\n\r\nconst createWindow = () => {\r\n  // Create the browser window.\r\n  const mainWindow = new BrowserWindow({\r\n    width: 800,\r\n    height: 600,\r\n    webPreferences: {\r\n      //preload: path.join(__dirname, './preload.js'),\r\n      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY\r\n    }\r\n  });\r\n\r\n  // and load the index.html of the app.\r\n  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);\r\n\r\n  // Open the DevTools.\r\n  mainWindow.webContents.openDevTools();\r\n};\r\n\r\n// This method will be called when Electron has finished\r\n// initialization and is ready to create browser windows.\r\n// Some APIs can only be used after this event occurs.\r\napp.on(\"ready\", createWindow);\r\n\r\n// Quit when all windows are closed, except on macOS. There, it's common\r\n// for applications and their menu bar to stay active until the user quits\r\n// explicitly with Cmd + Q.\r\napp.on(\"window-all-closed\", () => {\r\n  if (process.platform !== \"darwin\") {\r\n    app.quit();\r\n  }\r\n});\r\n\r\napp.on(\"activate\", () => {\r\n  // On OS X it's common to re-create a window in the app when the\r\n  // dock icon is clicked and there are no other windows open.\r\n  if (BrowserWindow.getAllWindows().length === 0) {\r\n    createWindow();\r\n  }\r\n});\r\n\r\n// In this file you can include the rest of your app's specific main process\r\n// code. You can also put them in separate files and import them here.\r\n\r\n// carga de archivos en base de datos con llamada activada pedida desde react\r\nipcMain.on(\"direccion\", (event, ubicacion) => {\r\n  SaveFilesToDB(ubicacion);\r\n  console.log(\"ubicacion:\", ubicacion);\r\n});\r\n\r\n\r\n\r\n\r\n\r\n\r\nipcMain.on(\"obtener-mensaje2\", async (event) => {\r\n\r\n await obtenerRegistrosEncontrados().then((registrosEncontrados) => {\r\n    // Aqu podemos acceder a los datos en la variable registrosEncontrados\r\n    event.sender.send(\"dateTimePartnbPathFromFile_Main_to_App\", registrosEncontrados)   \r\n  })\r\n  .catch((error) => {\r\n\r\n    console.error(\"Error al obtener registros:\", error);\r\n  });\r\n\r\n    \r\n});\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Funcin asincrnica que retorna una promesa con un mensaje\r\nfunction doSomethingAsync() {\r\n  return new Promise((resolve) => {\r\n    // Simulamos una operacin asincrnica\r\n    //setTimeout(() => {\r\n    resolve(\"Hola desde la promesa en main.js!\");\r\n    // }, 2000); // Esperamos 2 segundos antes de resolver la promesa\r\n  });\r\n}\r\n\r\n\r\nipcMain.on(\"obtener-mensaje\", async (event) => {\r\n  try {\r\n    const mensaje = await doSomethingAsync();\r\n    event.sender.send(\"mensaje-desde-main\", mensaje);\r\n  } catch (error) {\r\n    // Manejo de errores si es necesario\r\n    event.sender.send(\"mensaje-desde-main\", \"Error al obtener el mensaje\");\r\n  }\r\n});\r\n"],"names":["app","require","path","fs","Database","splitText","convertLastFiveColumns","splitTextTitulo","SubcadenaAGuionBajo","obtenerFechaMedicion","obtenerYearFromDate","obtenerMonthFromDate","readFilesInFolder","leerNumeroPartnb","actualizarNumeroPartnb","saveContenidoDataToDB","saveTituloDataToDB","partNumber","numero","console","log","checkForTildeFiles","ubicacion","readdirSync","some","file","includes","waitUntilFilesRemoved","Promise","resolve","setTimeout","userData","getAppPath","SaveFilesToDB","archivos","filter","extname","archivo","archivoTitulo","replace","Titulo","readFileSync","join","date","year","month","dbPath","existsSync","writeFileSync","contenido","tituloToDB","error","dbFolder","fileData","module","exports","dbFolderPath","files","result","filePath","statSync","isFile","db","verbose","stmt","prepare","rows","all","push","data","close","Datastore","callback","db2","filename","autoload","findOne","err","doc","numeroActualizado","update","upsert","numReplaced","sqlite","partnb","columnNames","slice","map","columnName","index","createTableStmt","column","run","insertStmt","Array","length","fill","transaction","forEach","row","documentExt","BucleRow","insertValues","value","undefined","document","properties","Object","keys","key","insertColumns","aux","from","buscarArchivosEnCarpeta","obtenerRegistrosEncontrados","resultadosArchivos","resultadosBusqueda","buscarFechaTiempoYPartnb","archivosEncontrados","dbPaths","promesas","reject","find","time","_id","registros","valoresEncontrados","dates","times","partnbs","registro","resultados","directorio","readdir","rutaArchivo","stat","stats","checkFolderExists","folderPath","isDirectory","code","text","split","i","columns","slicedColumns","concat","datosTituloInformeObj","palabrasClave","nextRowColumns","j","palabra","valor","obtenerDatosColumnasTexto","columna","newData","newRow","isNaN","Number","parsedValue","toFixed","toString","texto","indiceGuionBajo","indexOf","fecha","partes","BrowserWindow","ipcMain","createWindow","mainWindow","width","height","webPreferences","preload","MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY","loadURL","MAIN_WINDOW_WEBPACK_ENTRY","webContents","openDevTools","on","process","platform","quit","getAllWindows","event","then","registrosEncontrados","sender","send","catch","doSomethingAsync","mensaje"],"sourceRoot":""}